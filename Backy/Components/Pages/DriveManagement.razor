@page "/DriveManagement"
@inject ApplicationDbContext DbContext
@inject ILogger<DriveManagement> Logger
@inject ILoadingService LoadingService
@inject IDriveService DriveService
@inject NavigationManager NavigationManager
@inject ModalService ModalService
@inject ToastService ToastService
@rendermode InteractiveServer

<PageTitle>Drive Catalog - Backy</PageTitle>

<div class="d-flex justify-content-between align-items-center mb-4">
    <h1>Drive Catalog</h1>
    <!-- Search Bar -->
    <div class="input-group" style="max-width: 400px;">
        <input type="text" class="form-control search-bar" placeholder="Search drives..." @bind="searchQuery">
        <span class="input-group-text">
            <img src="/icons/search.svg" alt="Search Icon" class="search-icon search-bar theme-icon">
        </span>
    </div>
    <!-- Refresh Button / Create Pool -->
    <span>
        <button class="btn btn-secondary" @onclick="LoadDrives">Refresh</button>
        @if (SelectedDrives != null && SelectedDrives.Any())
        {
            <Button Color="ButtonColor.Primary" @onclick="OpenCreatePoolModal"> Create Pool </Button>
        }
        else
        {
            <Button Color="ButtonColor.Primary" Disabled="true"> Create Pool </Button>
        }
    </span>
</div>

<!-- New Drives -->
@if (FilteredNewDrives != null && FilteredNewDrives.Any())
{
    <h2>New Drives</h2>
    <div class="row">
    @foreach (var drive in FilteredNewDrives)
        {
            <div class="col-md-12">
                <NewDriveCard Model="@drive" OnProtect="@ProtectDrive" OnSelect="@SelectDrive"
                    IsSelected="@IsDriveSelected(drive.Serial!)" />
            </div>
        }
    </div>
}
else
{
    <p>No new drives found.</p>
}
<!-- Pool Groups -->
@if (FilteredPoolGroups != null && FilteredPoolGroups.Any())
{
    <h2>Pool Groups</h2>
    <div class="row">
    @foreach (var pool in FilteredPoolGroups)
        {
            <PoolGroupDriveCard @key="pool.PoolGroupId" Model="@pool" OnUnmountPool="@UnmountPool"
                OnRemovePoolGroup="@RemovePoolGroup" OnMountPool="@MountPool" OnRenamePoolGroup="@RenamePoolGroup"
                OnForceAddDrive="@ForceAddDrive" />
        }
    </div>
}

<!-- Protected Drives -->
@if (ProtectedDrives != null && ProtectedDrives.Any())
{
    <h2>Protected Drives</h2>
    <div class="row">
    @foreach (var drive in ProtectedDrives)
        {
            <div class="col-md-12">
                <ProtectedDriveCard Model="@drive" OnUnprotect="@UnprotectDrive" />
            </div>
        }
    </div>
}

<!-- Create Pool Modal -->
<Modal @ref="createPoolModal" Title="Create Pool">
    <BodyTemplate>
        @if (IsPoolCreationInProgress)
        {
            <p>Creating pool...</p>
        }
        else if (CreatePoolResultMessage != null)
        {
            <pre class="pool-result-message">
                @CreatePoolResultMessage

                @foreach (var output in CommandOutputs)
                {
                    @output
                }
                                            </pre>
        }
        else
        {
            <EditForm id="createPoolForm" EditContext="@createPoolEditContext" OnValidSubmit="HandleCreatePool">
                <DataAnnotationsValidator />
                <ValidationSummary />

                <div class="mb-3">
                    <label for="poolLabel" class="form-label">Pool Label</label>
                    <InputText id="poolLabel" class="form-control" @bind-Value="CreatePoolRequest.PoolLabel" required />
                    <ValidationMessage For="@(() => CreatePoolRequest.PoolLabel)" />
                </div>

                <!-- Drive Labels -->
                @foreach (var drive in SelectedDrives ?? Enumerable.Empty<Drive>())
                {
                    var driveSerial = drive.Serial!;
                    <div class="mb-3">
                        <label class="form-label">Drive Label (@driveSerial)</label>
                        <InputText class="form-control" @bind-Value="CreatePoolRequest.DriveLabels[driveSerial]" />
                    </div>
                }
            </EditForm>
        }
    </BodyTemplate>
    <FooterTemplate>
        @if (IsPoolCreationInProgress)
        {
            <Button Color="ButtonColor.Secondary" Disabled="true">Please wait...</Button>
        }
        else if (CreatePoolResultMessage != null)
        {
            <Button Color="ButtonColor.Secondary" @onclick="CloseCreatePoolModal">Close</Button>
        }
        else
        {
            <Button Color="ButtonColor.Secondary" @onclick="CloseCreatePoolModal">Cancel</Button>
            <button type="submit" class="btn btn-primary" form="createPoolForm">Create Pool</button>
        }
    </FooterTemplate>
</Modal>


<!-- Rename Pool Modal -->
<Modal @ref="renamePoolModal" Title="Rename Pool">
    <BodyTemplate>
        <EditForm id="renamePoolForm" EditContext="@renamePoolEditContext" OnValidSubmit="HandleRenamePool">
            <DataAnnotationsValidator />
            <ValidationSummary />
            <div class="mb-3">
                <label for="newPoolLabel" class="form-label">New Pool Label</label>
                <InputText id="newPoolLabel" class="form-control" @bind-Value="RenamePoolRequest.NewPoolLabel"
                    required />
                <ValidationMessage For="@(() => RenamePoolRequest.NewPoolLabel)" />
            </div>

            <!-- Drive Labels -->
            @foreach (var driveLabel in RenamePoolRequest.DriveLabels)
            {
                <div class="mb-3">
                    <label class="form-label">Drive Label (@driveLabel.DriveId)</label>
                    <InputText class="form-control" @bind-Value="driveLabel.Label" />
                    <ValidationMessage For="@(() => driveLabel.Label)" />
                </div>
            }
        </EditForm>
    </BodyTemplate>
    <FooterTemplate>
        <Button Color="ButtonColor.Secondary" @onclick="CloseRenamePoolModal">Close</Button>
        <button type="submit" class="btn btn-primary" form="renamePoolForm">Rename Pool</button>
    </FooterTemplate>
</Modal>

@code {
    private List<PoolGroup> PoolGroups { get; set; } = new List<PoolGroup>();
    private List<Drive> NewDrives { get; set; } = new List<Drive>();
    private List<ProtectedDrive> ProtectedDrives { get; set; } = new List<ProtectedDrive>();
    private List<Drive> SelectedDrives { get; set; } = new List<Drive>();
    private CreatePoolRequest CreatePoolRequest { get; set; } = new CreatePoolRequest
        {
            PoolLabel = string.Empty,
            DriveSerials = new List<string>(),
            DriveLabels = new Dictionary<string, string>()
        };
    private PoolGroup PoolToRename { get; set; } = new PoolGroup();
    private EditContext? createPoolEditContext;
    private EditContext? renamePoolEditContext;
    private RenamePoolRequest RenamePoolRequest { get; set; } = new RenamePoolRequest
        {
            NewPoolLabel = string.Empty,
            DriveLabels = new List<Backy.Models.DriveLabel>()
        };
    private List<string> CommandOutputs { get; set; } = new List<string>(); // To store command outputs
    private string? CreatePoolResultMessage { get; set; } = null;

    private Modal createPoolModal = default!;
    private Modal renamePoolModal = default!;
    private bool IsPoolCreationInProgress { get; set; } = false;

    private string searchQuery = string.Empty;

    private IEnumerable<Drive> FilteredNewDrives => NewDrives.Where(d => IsDriveMatch(d));

    private IEnumerable<PoolGroup> FilteredPoolGroups => PoolGroups.Where(pg => IsPoolGroupMatch(pg));

    private IEnumerable<ProtectedDrive> FilteredProtectedDrives => ProtectedDrives.Where(pd => IsDriveMatch(new Drive
        {
            Name = pd.Name,
            Label = pd.Label,
            Vendor = pd.Vendor,
            Model = pd.Model,
            Serial = pd.Serial
        }));

    private bool IsDriveMatch(Drive drive)
    {
        if (string.IsNullOrWhiteSpace(searchQuery))
        {
            Logger.LogInformation($"IsDriveMatch: searchQuery is empty. Drive {drive.Serial} matches.");
            return true;
        }

        var query = searchQuery.ToLowerInvariant();
        bool match = (drive.Name?.ToLowerInvariant().Contains(query) ?? false)
        || (drive.Label?.ToLowerInvariant().Contains(query) ?? false)
        || (drive.Vendor?.ToLowerInvariant().Contains(query) ?? false)
        || (drive.Model?.ToLowerInvariant().Contains(query) ?? false)
        || (drive.Serial?.ToLowerInvariant().Contains(query) ?? false);

        Logger.LogInformation($"IsDriveMatch: Drive {drive.Serial} match status: {match}");
        return match;
    }


    private bool IsPoolGroupMatch(PoolGroup poolGroup)
    {
        if (string.IsNullOrWhiteSpace(searchQuery))
            return true;
        var query = searchQuery.ToLowerInvariant();
        return (poolGroup.GroupLabel?.ToLowerInvariant().Contains(query) ?? false)
        || poolGroup.Drives.Any(d => IsDriveMatch(new Drive
            {
                Label = d.Label,
                Vendor = d.Vendor,
                Model = d.Model,
                Serial = d.Serial
            }));
    }

    protected override async Task OnInitializedAsync()
    {
        createPoolEditContext = new EditContext(CreatePoolRequest);
        renamePoolEditContext = new EditContext(RenamePoolRequest);
        Logger.LogInformation("Drive Management page initialized.");
        await LoadDrives();
    }

    private async Task LoadDrives()
    {
        try
        {
            await LoadingService.ShowLoading();
            await OrganizeDrives();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading drives.");
            ToastService.Notify(new(ToastType.Danger, $"Error: {ex.Message}."));
        }
        finally
        {
            await LoadingService.HideLoading();
        }
    }

    private async Task OrganizeDrives()
    {
        var activeDrives = await DriveService.UpdateActiveDrivesAsync();
        Logger.LogInformation($"Found {activeDrives.Count} active drives.");

        PoolGroups = await DbContext.PoolGroups.Include(pg => pg.Drives).ToListAsync();
        Logger.LogInformation($"Loaded {PoolGroups.Count} pool groups from the database.");

        ProtectedDrives = await DbContext.ProtectedDrives.ToListAsync();
        Logger.LogInformation($"Loaded {ProtectedDrives.Count} protected drives from the database.");

        bool changesMade = false; // Flag to track if any changes are made

        // Update connected status and properties for drives in pools
        foreach (var pool in PoolGroups)
        {
            var duplicateDriveIds = pool.Drives
            .GroupBy(d => d.Id)
            .Where(g => g.Count() > 1)
            .Select(g => g.Key)
            .ToList();

            if (duplicateDriveIds.Any())
            {
                Logger.LogWarning($"Pool {pool.GroupLabel} has duplicate drive IDs: {string.Join(", ", duplicateDriveIds)}");

                // Remove duplicate drives
                pool.Drives = pool.Drives
                .GroupBy(d => d.Id)
                .Select(g => g.First())
                .ToList();
                changesMade = true;
            }

            bool allConnected = true;
            foreach (var drive in pool.Drives)
            {
                // Find matching active drive
                var activeDrive = activeDrives.FirstOrDefault(d => d.Serial == drive.Serial);
                if (activeDrive != null)
                {
                    // Update properties
                    if (!drive.IsConnected || drive.Vendor != activeDrive.Vendor || drive.Model != activeDrive.Model ||
                    drive.IsMounted != activeDrive.IsMounted || drive.DevPath != activeDrive.IdLink ||
                    drive.Size != activeDrive.Size)
                    {
                        drive.IsConnected = true;
                        drive.Vendor = activeDrive.Vendor;
                        drive.Model = activeDrive.Model;
                        drive.IsMounted = activeDrive.IsMounted;
                        drive.DevPath = activeDrive.IdLink;
                        drive.Size = activeDrive.Size;
                        changesMade = true;
                    }
                }
                else
                {
                    if (drive.IsConnected)
                    {
                        drive.IsConnected = false;
                        changesMade = true;
                    }
                    allConnected = false;
                }
            }

            // Set PoolEnabled based on whether all drives are connected
            pool.AllDrivesConnected = allConnected;

            if (pool.PoolEnabled)
            {
                // Fetch Pool Status
                string status = DriveService.FetchPoolStatus(pool.PoolGroupId);
                if (pool.PoolStatus != status)
                {
                    pool.PoolStatus = status;
                    changesMade = true;
                }

                if (!string.IsNullOrEmpty(pool.MountPath))
                {
                    var (size, used, available, usePercent) = DriveService.GetMountPointSize(pool.MountPath);

                    if (size > 0 && (pool.Size != size || pool.Used != used || pool.Available != available || pool.UsePercent !=
                    usePercent))
                    {
                        pool.Size = size;
                        pool.Used = used;
                        pool.Available = available;
                        pool.UsePercent = usePercent;
                        changesMade = true;
                    }
                }
            }
        }

        // NewDrives: drives that are active but not in any pool and not protected
        var pooledDriveSerials = PoolGroups.SelectMany(p => p.Drives).Select(d => d.Serial).ToHashSet();
        var protectedSerials = ProtectedDrives.Select(pd => pd.Serial).ToHashSet();

        // Ensure uniqueness by grouping by Serial
        NewDrives = activeDrives
        .Where(d => !pooledDriveSerials.Contains(d.Serial) && !protectedSerials.Contains(d.Serial))
        .GroupBy(d => d.Serial)
        .Select(g => g.First())
        .ToList();

        Logger.LogInformation($"NewDrives Count after filtering: {NewDrives.Count}");

        if (changesMade)
        {
            await DbContext.SaveChangesAsync();
            Logger.LogInformation("Changes saved to the database.");
        }
    }


    private async Task ProtectDrive(string serial)
    {
        try
        {
            Logger.LogInformation($"Attempting to protect drive with serial: {serial}");
            var result = await DriveService.ProtectDriveAsync(serial);
            if (result.Success)
            {
                Logger.LogInformation($"Drive {serial} protected successfully.");
                ToastService.Notify(new(ToastType.Success, $"{result.Message}"));
                await LoadDrives();
            }
            else
            {
                Logger.LogWarning($"Failed to protect drive {serial}: {result.Message}");
                ToastService.Notify(new(ToastType.Warning, $"{result.Message}"));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error protecting drive.");
            ToastService.Notify(new(ToastType.Warning, $"Error: {ex.Message}"));
        }
    }

    private async Task UnprotectDrive(string serial)
    {
        try
        {
            Logger.LogInformation($"Attempting to unprotect drive with serial: {serial}");
            var result = await DriveService.UnprotectDriveAsync(serial);
            if (result.Success)
            {
                Logger.LogInformation($"Drive {serial} unprotected successfully.");
                ToastService.Notify(new(ToastType.Success, $"{result.Message}"));
                await LoadDrives();
            }
            else
            {
                Logger.LogWarning($"Failed to unprotect drive {serial}: {result.Message}");
                ToastService.Notify(new(ToastType.Warning, $"{result.Message}"));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error unprotecting drive.");
            ToastService.Notify(new(ToastType.Warning, $"Error: {ex.Message}"));
        }
    }

    private void SelectDrive(string serial)
    {
        Logger.LogInformation($"Selecting drive with serial: {serial}");
        var drive = NewDrives.FirstOrDefault(d => d.Serial == serial);
        if (drive != null)
        {
            if (SelectedDrives.Any(d => d.Serial == serial))
            {
                // Deselect the drive
                SelectedDrives.RemoveAll(d => d.Serial == serial);
                Logger.LogInformation($"Drive {serial} deselected.");
            }
            else
            {
                // Select the drive
                SelectedDrives.Add(drive);
                Logger.LogInformation($"Drive {serial} selected.");
            }
            StateHasChanged(); // Update the UI
        }
        else
        {
            Logger.LogWarning($"Drive {serial} not found.");
            ToastService.Notify(new(ToastType.Danger, $"Drive {serial} not found."));
        }
    }

    private bool IsDriveSelected(string? serial)
    {
        if (serial == null)
            return false;
        return SelectedDrives.Any(d => d.Serial == serial);
    }

    private async Task OpenCreatePoolModal()
    {
        Logger.LogInformation("Opening Create Pool modal.");

        // Create a new CreatePoolRequest instance with selected drives
        CreatePoolRequest = new CreatePoolRequest
            {
                PoolLabel = "",
                DriveSerials = SelectedDrives.Select(d => d.Serial!).ToList(),
                DriveLabels = SelectedDrives.ToDictionary(d => d.Serial!, d => d.Label ?? "")
            };

        // Reassign the EditContext to the new CreatePoolRequest instance
        createPoolEditContext = new EditContext(CreatePoolRequest);

        // Show the modal
        await createPoolModal.ShowAsync();
    }

    private async Task CloseCreatePoolModal()
    {
        // Reset the result message
        CreatePoolResultMessage = null;

        // Hide the modal
        await createPoolModal.HideAsync();

        // Clear selected drives
        SelectedDrives.Clear();

        // Reset CreatePoolRequest to a new instance
        CreatePoolRequest = new CreatePoolRequest
            {
                PoolLabel = string.Empty,
                DriveSerials = new List<string>(),
                DriveLabels = new Dictionary<string, string>()
            };

        // Reassign the EditContext to the new CreatePoolRequest instance
        createPoolEditContext = new EditContext(CreatePoolRequest);

        // Trigger UI update
        StateHasChanged();

        // Reload drives to refresh the state
        await LoadDrives();
    }

    private async Task HandleCreatePool()
    {
        Logger.LogInformation("Creating pool...");
        try
        {
            IsPoolCreationInProgress = true;
            CommandOutputs.Clear();
            CreatePoolResultMessage = null;
            var (success, message, outputs) = await DriveService.CreatePoolAsync(CreatePoolRequest);
            CommandOutputs.AddRange(outputs);
            if (success)
            {
                Logger.LogInformation($"Pool created successfully: {message}");
                CreatePoolResultMessage = "Pool created successfully.";
            }
            else
            {
                Logger.LogWarning($"Pool creation failed: {message}");
                CreatePoolResultMessage = $"Pool creation failed: {message}";
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error creating pool.");
            CreatePoolResultMessage = $"Error: {ex.Message}.";
        }
        finally
        {
            IsPoolCreationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task UnmountPool(PoolGroup poolGroup)
    {
        try
        {
            await LoadingService.ShowLoading();
            var result = await DriveService.UnmountPoolAsync(poolGroup.PoolGroupGuid);
            if (result.Success)
            {
                ToastService.Notify(new(ToastType.Success, $"{result.Message}"));
                await LoadDrives();
            }
            else
            {
                ToastService.Notify(new(ToastType.Warning, $"{result.Message}"));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Error unmounting pool '{poolGroup.GroupLabel}'.");
            ToastService.Notify(new(ToastType.Danger, $"Failed to unmount pool."));
        }
        finally
        {
            await LoadingService.HideLoading();
        }
    }

    private async Task RemovePoolGroup(PoolGroup poolGroup)
    {
        try
        {
            await LoadingService.ShowLoading();
            var result = await DriveService.RemovePoolGroupAsync(poolGroup.PoolGroupGuid);
            if (result.Success)
            {
                ToastService.Notify(new(ToastType.Success, $"{result.Message}"));
                await LoadDrives();
            }
            else
            {
                ToastService.Notify(new(ToastType.Warning, $"{result.Message}"));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Error removing pool '{poolGroup.GroupLabel}'.");
            ToastService.Notify(new(ToastType.Danger, $"Failed to remove pool."));
        }
        finally
        {
            await LoadingService.HideLoading();
        }
    }

    private async Task MountPool(PoolGroup poolGroup)
    {
        try
        {
            await LoadingService.ShowLoading();
            var result = await DriveService.MountPoolAsync(poolGroup.PoolGroupGuid);
            if (result.Success)
            {
                ToastService.Notify(new(ToastType.Success, $"{result.Message}"));
                await LoadDrives();
            }
            else
            {
                ToastService.Notify(new(ToastType.Warning, $"{result.Message}"));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Error mounting pool '{poolGroup.GroupLabel}'.");
            ToastService.Notify(new(ToastType.Danger, $"Failed to mount pool."));
        }
        finally
        {
            await LoadingService.HideLoading();
        }
    }

    private async Task RenamePoolGroup(PoolGroup poolGroup)
    {
        Logger.LogInformation($"Renaming pool group: {poolGroup.GroupLabel}");
        PoolToRename = poolGroup;
        RenamePoolRequest = new RenamePoolRequest
            {
                PoolGroupGuid = poolGroup.PoolGroupGuid,
                NewPoolLabel = poolGroup.GroupLabel,
                DriveLabels = poolGroup.Drives.Select(d => new DriveLabel
                {
                    DriveId = d.Id,
                    Label = d.Label
                }).ToList()
            };
        renamePoolEditContext = new EditContext(RenamePoolRequest); // Reinitialize EditContext
        await renamePoolModal.ShowAsync();
    }


    private async Task ForceAddDrive(PoolDrive drive)
    {
        try
        {
            await LoadingService.ShowLoading();
            if (drive.PoolGroup != null && drive.DevPath != null)
            {
                var result = await DriveService.ForceAddDriveAsync(drive.Id, drive.PoolGroup.PoolGroupGuid, drive.DevPath);
                if (result.Success)
                {
                    ToastService.Notify(new(ToastType.Success, $"{result.Message}"));
                    await LoadDrives();
                }
                else
                {
                    ToastService.Notify(new(ToastType.Warning, $"{result.Message}"));
                }
            }
            else
            {
                Logger.LogWarning("Drive PoolGroup or DevPath is null.");
                ToastService.Notify(new(ToastType.Danger, "Failed to force add drive due to missing information."));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Error force adding drive '{drive.Label}'.");
            ToastService.Notify(new(ToastType.Danger, $"Failed to force add drive."));
        }
        finally
        {
            await LoadingService.HideLoading();
        }
    }


    private async Task CloseRenamePoolModal()
    {
        PoolToRename = new PoolGroup(); // Initialize to avoid null reference
        RenamePoolRequest = new RenamePoolRequest
            {
                NewPoolLabel = string.Empty,
                DriveLabels = new List<Backy.Models.DriveLabel>()
            };
        await renamePoolModal.HideAsync();
    }

    private async Task HandleRenamePool()
    {
        Logger.LogInformation("Renaming pool...");
        try
        {
            await LoadingService.ShowLoading();
            var (success, message) = await DriveService.RenamePoolGroupAsync(RenamePoolRequest);
            if (success)
            {
                Logger.LogInformation($"Pool renamed successfully: {message}");
                var modalOption = new ModalOption
                    {
                        Title = "Rename Pool",
                        Message = "Pool renamed successfully.",
                        Type = ModalType.Success
                    };
                await ModalService.ShowAsync(modalOption);
                await LoadDrives(); // Refresh the data
            }
            else
            {
                Logger.LogWarning($"Pool renaming failed: {message}");
                var modalOption = new ModalOption
                    {
                        Title = "Rename Pool",
                        Message = $"Pool renaming failed: {message}",
                        Type = ModalType.Danger
                    };
                await ModalService.ShowAsync(modalOption);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error renaming pool.");
            var modalOption = new ModalOption
                {
                    Title = "Rename Pool",
                    Message = $"Error: {ex.Message}.",
                    Type = ModalType.Danger
                };
            await ModalService.ShowAsync(modalOption);
        }
        finally
        {
            await LoadingService.HideLoading();
        }
    }

}
