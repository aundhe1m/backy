@page "/DriveManagement"
@inject ApplicationDbContext DbContext
@inject ILogger<DriveManagement> Logger
@inject ILoadingService LoadingService
@inject IAppDriveService AppDriveService
@inject NavigationManager NavigationManager
@inject ModalService ModalService
@inject ToastService ToastService
@implements IDisposable
@rendermode InteractiveServer

<PageTitle>Drive Management - Backy</PageTitle>

<!-- Header Section: Contains the page title, search bar, and action buttons (Refresh and Create Pool Group) -->
<div class="d-flex justify-content-between align-items-center mb-4">
    <h1>Drive Management</h1>

    <!-- Search Bar -->
    <div class="input-group" style="max-width: 400px;">
        <input type="text" class="form-control search-bar" placeholder="Search drives..." @bind="searchQuery">
        <span class="input-group-text">
            <img src="/icons/search.svg" alt="Search Icon" class="search-icon search-bar theme-icon">
        </span>
    </div>

    <!-- Refresh Button and Create Pool Group Button -->
    <span>
        <!-- Refresh Button -->
        <Tooltip Title="Refresh" Color="TooltipColor.Dark">
            <button class="btn btn-info" @onclick="ManualRefresh" disabled="@isBackgroundRefreshing">
                @if (isBackgroundRefreshing)
                {
                    <Spinner Type="SpinnerType.Grow" Size="SpinnerSize.Small" Color="SpinnerColor.Light" />
                }
                else
                {
                    <img src="/icons/arrow-clockwise.svg" alt="Refresh" style="height: 24px;" class="theme-icon" />
                }
            </button>
        </Tooltip>

        <!-- Create Pool Group Button -->
        <Tooltip Title="Create Pool Group" Color="TooltipColor.Dark">
            @if (SelectedDrives != null && SelectedDrives.Any())
            {
                <button class="btn btn-success" @onclick="OpenCreatePoolModal">
                    <img src="/icons/plus-square-fill.svg" alt="Create Pool Group" style="height: 24px;"
                        class="theme-icon" />
                </button>
            }
            else
            {
                <button class="btn btn-success" disabled>
                    <img src="/icons/plus-square.svg" alt="Create Pool Group" style="height: 24px;" class="theme-icon" />
                </button>
            }
        </Tooltip>
    </span>
</div>

<!-- Content Section: Displays New Drives, Pool Groups, and Protected Drives -->
<!-- New Drives Section -->
<div class="drive-management-container">
    <h2 class="section-title">New Drives</h2>
    @if (FilteredNewDrives != null && FilteredNewDrives.Any())
    {
        <div class="row">
            @foreach (var drive in FilteredNewDrives)
            {
                <div class="col-md-12">
                    <NewDriveCard Model="@drive" OnProtect="@ProtectDrive" OnSelect="@SelectDrive"
                        IsSelected="@IsDriveSelected(drive.Serial!)" />
                </div>
            }
        </div>
    }
    else
    {
        <p>No new drives found.</p>
    }
</div>

<!-- Pool Groups Section -->
<div class="drive-management-container">
    <h2 class="section-title">Pool Groups</h2>

    @if (FilteredPoolGroups != null && FilteredPoolGroups.Any())
    {
        <div class="row">
            @foreach (var pool in FilteredPoolGroups)
            {
                <div class="col-md-12">
                    <PoolGroupDriveCard @key="pool.PoolGroupId" Model="@pool" OnUnmountPool="@UnmountPool"
                        OnRemovePoolGroup="@RemovePoolGroup" OnMountPool="@MountPool" OnRenamePoolGroup="@RenamePoolGroup"
                        OnForceAddDrive="@ForceAddDrive" />
                </div>
            }
        </div>
    }
</div>

<!-- Protected Drives Section -->
<div class="drive-management-container">
    <h2 class="section-title">Protected Drives</h2>
    @if (ProtectedDrives != null && ProtectedDrives.Any())
    {
        <div class="row">
            @foreach (var drive in ProtectedDrives)
            {
                <div class="col-md-12">
                    <ProtectedDriveCard Model="@drive" OnUnprotect="@UnprotectDrive" />
                </div>
            }
        </div>
    }
</div>

<!-- Creating Pools Section -->
<div class="drive-management-container">
    <h2 class="section-title">Creating Pools</h2>
    @if (CreatingPools != null && CreatingPools.Any())
    {
        <div class="row">
            @foreach (var pool in CreatingPools)
            {
                <div class="col-md-12">
                    <CreatingPoolCard @key="pool.PoolGroupGuid" Model="@pool" 
                                     OnCreationComplete="@HandlePoolCreationComplete"
                                     OnCancelCreation="@HandlePoolCreationCancel" />
                </div>
            }
        </div>
    }
</div>

<!-- 
    Modals Section: Contains modals for Creating Pools, Renaming Pools, and Displaying Process Lists
-->

<!-- Create Pool Modal -->
<Modal @ref="createPoolModal" Title="Create Pool" Size="ModalSize.Large">
    <BodyTemplate>
        @if (IsPoolCreationInProgress)
        {
            <h3>Creating pool...</h3>
        }
        else if (CreatePoolResultMessage != null)
        {
            <!-- Display Command Outputs -->
            <div class="console-output">
            <pre>@string.Join("\n", CommandOutputs)<br></pre>
        </div>
            <br>
            <!-- Success or Error Alert -->
            @if (CreatePoolResultSuccess == true)
            {
                <Alert Color="AlertColor.Success">
                    <span style="display: flex;">
                        <img src="/icons/check-circle-fill-green.svg" alt="Success Icon"
                            style="height: 24px; margin-right: 8px;" />
                        <h5 style="margin: 0;">Success</h5>
                    </span>
                    <hr style="border: 1px solid gray; margin-top: 8px; margin-bottom: 8px;" />
                    <div>
                        @CreatePoolResultMessage
                    </div>
                </Alert>
            }
            else
            {
                <Alert Color="AlertColor.Danger">
                    <span style="display: flex;">
                        <img src="/icons/exclamation-triangle-fill-red.svg" alt="Error Icon"
                            style="height: 24px; margin-right: 8px;" />
                        <h5>Error</h5>
                    </span>
                    <hr style="border: 1px solid gray; margin-top: 8px; margin-bottom: 8px;" />
                    <div>
                        @CreatePoolResultMessage
                    </div>
                </Alert>
            }
        }
        else
        {
            <!-- Create Pool Form -->
            <EditForm id="createPoolForm" EditContext="@createPoolEditContext" OnValidSubmit="HandleCreatePool">
                <DataAnnotationsValidator />
                <ValidationSummary />

                <!-- Pool Label Input with Icon -->
                <div class="mb-3">
                    <h5>Drive Labels</h5>
                    <div class="d-flex align-items-center">
                        <img src="/icons/hdd-rack.svg" alt="Pool Icon" style="height: 24px; margin-right: 8px;"
                            class="theme-icon" />
                        <div class="flex-grow-1 d-flex align-items-center">
                            <label for="poolLabel" class="form-label me-2">Pool Label:</label>
                            <InputText placeholder="Enter pool label" id="poolLabel" class="form-control flex-grow-1"
                                @bind-Value="CreatePoolRequest.PoolLabel" required @oninput="HandlePoolLabelChanged" />
                            <ValidationMessage For="@(() => CreatePoolRequest.PoolLabel)" />
                        </div>
                    </div>
                </div>

                <!-- Drive Labels Section using PoolDriveLabelCard Component -->
                <div class="drive-labels-section">
                    <h5>Drive Labels</h5>
                    @foreach (var drive in SelectedDrives ?? Enumerable.Empty<Drive>())
                    {
                        var driveSerial = drive.Serial!;
                        <PoolDriveLabelCard Model="@drive" DriveLabel="@CreatePoolRequest.DriveLabels[driveSerial]"
                            OnLabelChangedCallback="@(async (newLabel) => await OnDriveLabelChanged(driveSerial, newLabel))" />
                    }
                </div>
            </EditForm>
        }
    </BodyTemplate>
    <FooterTemplate>
        @if (IsPoolCreationInProgress)
        {
            <Button Color="ButtonColor.Secondary" Disabled="true">
                <Spinner Type="SpinnerType.Dots" Class="me-3" Color="SpinnerColor.Light" />
                Creating...
            </Button>
        }
        else if (CreatePoolResultMessage != null)
        {
            <Button Color="ButtonColor.Secondary" @onclick="CloseCreatePoolModal">Close</Button>
        }
        else
        {
            <Button Type="ButtonType.Button" Color="ButtonColor.Secondary" @onclick="CloseCreatePoolModal">Cancel</Button>
            <Button Type="ButtonType.Submit" Color="ButtonColor.Primary" Form="createPoolForm">Create Pool</Button>
        }
    </FooterTemplate>
</Modal>

<!-- Rename Pool Modal -->
<Modal @ref="renamePoolModal" Title="Rename Pool" Size="ModalSize.Large">
    <BodyTemplate>
        @if (IsRenameInProgress)
        {
            <h3>Renaming pool...</h3>
        }
        else if (RenameResultMessage != null)
        {
            <!-- Success or Error Alert -->
            @if (RenameResultSuccess == true)
            {
                <Alert Color="AlertColor.Success">
                    <span style="display: flex;">
                        <img src="/icons/check-circle-fill-green.svg" alt="Success Icon"
                            style="height: 24px; margin-right: 8px;" />
                        <h5 style="margin: 0;">Success</h5>
                    </span>
                    <hr style="border: 1px solid gray; margin-top: 8px; margin-bottom: 8px;" />
                    <div>
                        @RenameResultMessage
                    </div>
                </Alert>
            }
            else
            {
                <Alert Color="AlertColor.Danger">
                    <span style="display: flex;">
                        <img src="/icons/exclamation-triangle-fill-red.svg" alt="Error Icon"
                            style="height: 24px; margin-right: 8px;" />
                        <h5>Error</h5>
                    </span>
                    <hr style="border: 1px solid gray; margin-top: 8px; margin-bottom: 8px;" />
                    <div>
                        @RenameResultMessage
                    </div>
                </Alert>
            }
        }
        else
        {
            <!-- Rename Pool Form -->
            <EditForm id="renamePoolForm" EditContext="@renamePoolEditContext" OnValidSubmit="HandleRenamePool">
                <DataAnnotationsValidator />
                <ValidationSummary />

                <!-- New Pool Label Input with Icon -->
                <div class="mb-3">
                    <h5>New Pool Label</h5>
                    <div class="d-flex align-items-center">
                        <img src="/icons/pencil-square.svg" alt="Rename Icon" style="height: 24px; margin-right: 8px;"
                            class="theme-icon" />
                        <div class="flex-grow-1">
                            <InputText id="newPoolLabel" class="form-control" @bind-Value="RenamePoolRequest.NewPoolLabel"
                                required placeholder="Enter new pool label" />
                            <ValidationMessage For="@(() => RenamePoolRequest.NewPoolLabel)" />
                        </div>
                    </div>
                </div>

                <!-- Drive Labels Section using PoolDriveLabelCard Component -->
                <div class="drive-labels-section">
                    <h5>Drive Labels</h5>
                    @foreach (var driveLabel in RenamePoolRequest.DriveLabels)
                    {
                        var drive = GetDriveById(driveLabel.DriveId);
                        if (drive != null)
                        {
                            <PoolDriveLabelCard Model="@drive" DriveLabel="@driveLabel.Label"
                                OnLabelChangedCallback="@(async (newLabel) => await OnRenameDriveLabelChanged(driveLabel.DriveId, newLabel))" />
                        }
                    }
                </div>
            </EditForm>
        }
    </BodyTemplate>
    <FooterTemplate>
        @if (IsRenameInProgress)
        {
            <Button Color="ButtonColor.Secondary" Disabled="true">
                <Spinner Type="SpinnerType.Dots" Class="me-3" Color="SpinnerColor.Light" />
                Renaming...
            </Button>
        }
        else if (RenameResultMessage != null)
        {
            <Button Color="ButtonColor.Secondary" @onclick="CloseRenamePoolModal">Close</Button>
        }
        else
        {
            <Button Type="ButtonType.Button" Color="ButtonColor.Secondary" @onclick="CloseRenamePoolModal">Cancel</Button>
            <Button Type="ButtonType.Submit" Color="ButtonColor.Primary" Form="renamePoolForm">Rename Pool</Button>
        }
    </FooterTemplate>
</Modal>

<!-- Process List Modal -->
<Modal @ref="processListModal" Title="Processes Preventing Unmount" Size="ModalSize.Large">
    <BodyTemplate>
        @if (ProcessList == null)
        {
            <p>Loading processes...</p>
        }
        else if (!ProcessList.Any())
        {
            <p>No processes are currently using the mount point.</p>
        }
        else
        {
            <p>The following processes are preventing the pool from being unmounted:</p>
            <table class="table table-striped">
            <thead>
                <tr>
                    <th>PID</th>
                    <th>Command</th>
                    <th>User</th>
                    <th>Name</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var process in ProcessList)
                    {
                        <tr>
                            <td>@process.PID</td>
                            <td>@process.Command</td>
                            <td>@process.User</td>
                            <td>@process.Name</td>
                        </tr>
                    }
                </tbody>
            </table>
            <p>Do you want to kill these processes and retry unmounting the pool?</p>
        }
    </BodyTemplate>
    <FooterTemplate>
        @if (ProcessList != null && ProcessList.Any())
        {
            <Button Color="ButtonColor.Danger" @onclick="KillProcesses">Kill Processes</Button>
            <Button Color="ButtonColor.Secondary" @onclick="CloseProcessListModal">Cancel</Button>
        }
        else
        {
            <Button Color="ButtonColor.Secondary" @onclick="CloseProcessListModal">Close</Button>
        }
    </FooterTemplate>
</Modal>

@code {
    // ---------------------------
    // Properties
    // ---------------------------
    private List<PoolGroup> PoolGroups { get; set; } = new List<PoolGroup>();
    private List<Drive> NewDrives { get; set; } = new List<Drive>();
    private List<ProtectedDrive> ProtectedDrives { get; set; } = new List<ProtectedDrive>();
    private List<Drive> SelectedDrives { get; set; } = new List<Drive>();
    private bool isBackgroundRefreshing = false;
    private Timer? backgroundRefreshTimer;

    // Create Pool Request
    private CreatePoolRequest CreatePoolRequest { get; set; } = new CreatePoolRequest
        {
            PoolLabel = string.Empty,
            DriveSerials = new List<string>(),
            DriveLabels = new Dictionary<string, string>()
        };

    private HashSet<string> CustomDriveLabels { get; set; } = new HashSet<string>();

    private PoolGroup PoolToRename { get; set; } = new PoolGroup();
    private EditContext? createPoolEditContext;
    private EditContext? renamePoolEditContext;
    private RenamePoolRequest RenamePoolRequest { get; set; } = new RenamePoolRequest
        {
            NewPoolLabel = string.Empty,
            DriveLabels = new List<Backy.Models.DriveLabel>()
        };
    private List<string> CommandOutputs { get; set; } = new List<string>(); // To store command outputs
    private string? CreatePoolResultMessage { get; set; } = null;
    private bool? CreatePoolResultSuccess { get; set; } = null;

    // Modal References
    private Modal createPoolModal = default!;
    private Modal renamePoolModal = default!;
    private Modal processListModal = default!;
    private List<ProcessInfo>? ProcessList { get; set; } = null;
    private Guid? currentPoolGroupGuidForUnmount = null;

    // Rename Pool States
    private bool IsRenameInProgress { get; set; } = false;
    private string? RenameResultMessage { get; set; } = null;
    private bool? RenameResultSuccess { get; set; } = null;
    private List<string> RenameCommandOutputs { get; set; } = new List<string>();

    // Pool Creation State
    private bool IsPoolCreationInProgress { get; set; } = false;

    // Search Query
    private string searchQuery = string.Empty;

    // ---------------------------
    // Helper Methods
    // ---------------------------

    /// <summary>
    /// Retrieves a drive by its ID from the pool groups.
    /// </summary>
    /// <param name="driveId">The ID of the drive.</param>
    /// <returns>The <see cref="Drive"/> object if found; otherwise, null.</returns>
    private Drive? GetDriveById(int driveId)
    {
        foreach (var poolGroup in PoolGroups)
        {
            var drive = poolGroup.Drives.FirstOrDefault(d => d.Id == driveId)?.ToDrive();
            if (drive != null)
                return drive;
        }
        return null;
    }

    /// <summary>
    /// Filters new drives based on the search query.
    /// </summary>
    private IEnumerable<Drive> FilteredNewDrives => NewDrives.Where(d => IsDriveMatch(d));

    /// <summary>
    /// Filters pool groups based on the search query.
    /// </summary>
    private IEnumerable<PoolGroup> FilteredPoolGroups => PoolGroups.Where(pg => IsPoolGroupMatch(pg));

    /// <summary>
    /// Filters protected drives based on the search query.
    /// </summary>
    private IEnumerable<ProtectedDrive> FilteredProtectedDrives => ProtectedDrives.Where(pd => IsDriveMatch(new Drive
        {
            Name = pd.Name,
            Label = pd.Label,
            Vendor = pd.Vendor,
            Model = pd.Model,
            Serial = pd.Serial
        }));

    /// <summary>
    /// Determines if a drive matches the current search query.
    /// </summary>
    /// <param name="drive">The drive to check.</param>
    /// <returns>True if the drive matches; otherwise, false.</returns>
    private bool IsDriveMatch(Drive drive)
    {
        if (string.IsNullOrWhiteSpace(searchQuery))
        {
            Logger.LogInformation($"IsDriveMatch: searchQuery is empty. Drive {drive.Serial} matches.");
            return true;
        }

        var query = searchQuery.ToLowerInvariant();
        bool match = (drive.Name?.ToLowerInvariant().Contains(query) ?? false)
        || (drive.Label?.ToLowerInvariant().Contains(query) ?? false)
        || (drive.Vendor?.ToLowerInvariant().Contains(query) ?? false)
        || (drive.Model?.ToLowerInvariant().Contains(query) ?? false)
        || (drive.Serial?.ToLowerInvariant().Contains(query) ?? false);

        Logger.LogInformation($"IsDriveMatch: Drive {drive.Serial} match status: {match}");
        return match;
    }

    /// <summary>
    /// Determines if a pool group matches the current search query.
    /// </summary>
    /// <param name="poolGroup">The pool group to check.</param>
    /// <returns>True if the pool group matches; otherwise, false.</returns>
    private bool IsPoolGroupMatch(PoolGroup poolGroup)
    {
        if (string.IsNullOrWhiteSpace(searchQuery))
            return true;
        var query = searchQuery.ToLowerInvariant();
        return (poolGroup.GroupLabel?.ToLowerInvariant().Contains(query) ?? false)
        || poolGroup.Drives.Any(d => IsDriveMatch(new Drive
            {
                Label = d.Label,
                Vendor = d.Vendor,
                Model = d.Model,
                Serial = d.Serial
            }));
    }

    /// <summary>
    /// Gets pools that are currently being created.
    /// </summary>
    private IEnumerable<PoolGroup> CreatingPools => PoolGroups.Where(p => p.PoolStatus == "creating" || p.PoolStatus == "Creating");

    // ---------------------------
    // Lifecycle Methods
    // ---------------------------

    protected override async Task OnInitializedAsync()
    {
        createPoolEditContext = new EditContext(CreatePoolRequest);
        renamePoolEditContext = new EditContext(RenamePoolRequest);
        Logger.LogInformation("Drive Management page initialized.");
        
        // Load initial data from the database
        await LoadDataFromDatabase();
        
        // Start a timer to poll for database changes
        StartDatabasePollingTimer();
        
        // Trigger a background refresh from the agent
        _ = BackgroundRefresh();
    }

    private void StartDatabasePollingTimer()
    {
        // Create a timer that checks for database updates every 10 seconds
        backgroundRefreshTimer = new Timer(async _ => 
        {
            await LoadDataFromDatabase();
            await InvokeAsync(StateHasChanged);
        }, null, 10000, 10000); // 10 second delay, 10 second interval
    }

    public void Dispose()
    {
        // Clean up the timer when the component is disposed
        backgroundRefreshTimer?.Dispose();
        backgroundRefreshTimer = null;
    }

    /// <summary>
    /// Load data directly from the database without waiting for the API
    /// </summary>
    private async Task LoadDataFromDatabase()
    {
        try
        {
            Logger.LogInformation("Loading data from database...");
            
            // Load pool groups with their drives
            PoolGroups = await DbContext.PoolGroups.Include(pg => pg.Drives).ToListAsync();
            Logger.LogInformation($"Loaded {PoolGroups.Count} pool groups from the database.");
            
            // Load protected drives
            ProtectedDrives = await DbContext.ProtectedDrives.ToListAsync();
            Logger.LogInformation($"Loaded {ProtectedDrives.Count} protected drives from the database.");
            
            // Get active drives from drive service with minimal API calls
            var activeDrives = await AppDriveService.UpdateActiveDrivesAsync();
            Logger.LogInformation($"Retrieved {activeDrives.Count} active drives.");
            
            // Filter out drives that are already in pools or protected
            var pooledDriveSerials = PoolGroups.SelectMany(pg => pg.Drives).Select(d => d.Serial).ToHashSet();
            var protectedSerials = ProtectedDrives.Select(pd => pd.Serial).ToHashSet();
            
            NewDrives = activeDrives
                .Where(d => !pooledDriveSerials.Contains(d.Serial) && !protectedSerials.Contains(d.Serial))
                .GroupBy(d => d.Serial)
                .Select(g => g.First())
                .ToList();
            
            Logger.LogInformation($"Found {NewDrives.Count} new drives after filtering.");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading data from database.");
        }
    }

    /// <summary>
    /// Manually triggered full refresh that shows loading overlay
    /// </summary>
    private async Task ManualRefresh()
    {
        try
        {
            await LoadingService.ShowLoading();
            await LoadDrives();
        }
        finally
        {
            await LoadingService.HideLoading();
        }
    }

    /// <summary>
    /// Background refresh that doesn't block the UI with a loading overlay
    /// </summary>
    private async Task BackgroundRefresh()
    {
        if (isBackgroundRefreshing)
            return;
            
        try
        {
            isBackgroundRefreshing = true;
            await InvokeAsync(StateHasChanged);
            await LoadDrives();
        }
        finally
        {
            isBackgroundRefreshing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    // ---------------------------
    // Data Loading and Organization
    // ---------------------------

    /// <summary>
    /// Loads drives and organizes them into new drives, pool groups, and protected drives.
    /// </summary>
    private async Task LoadDrives()
    {
        try
        {
            await OrganizeDrives();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading drives.");
            ToastService.Notify(new(ToastType.Danger, $"Error: {ex.Message}."));
        }
    }

    /// <summary>
    /// Organizes drives into new drives, pool groups, and protected drives.
    /// Updates the database if any changes are detected.
    /// </summary>
    private async Task OrganizeDrives()
    {
        var activeDrives = await AppDriveService.UpdateActiveDrivesAsync();
        Logger.LogInformation($"Found {activeDrives.Count} active drives.");

        PoolGroups = await DbContext.PoolGroups.Include(pg => pg.Drives).ToListAsync();
        Logger.LogInformation($"Loaded {PoolGroups.Count} pool groups from the database.");

        ProtectedDrives = await DbContext.ProtectedDrives.ToListAsync();
        Logger.LogInformation($"Loaded {ProtectedDrives.Count} protected drives from the database.");

        bool changesMade = false; // Flag to track if any changes are made

        // First, check with the Agent API which pools actually exist on the system
        try {
            // Get pool information from the Agent API
            var poolsApiTask = AppDriveService.GetPoolsAsync();
            
            // Set up a timeout for the API call
            var timeoutTask = Task.Delay(10000); // 10 seconds timeout
            
            // Wait for either the API call to complete or the timeout to occur
            if (await Task.WhenAny(poolsApiTask, timeoutTask) == timeoutTask)
            {
                // API call timed out
                Logger.LogWarning("Pool API call timed out. Some pools might be shown as offline.");
            }
            else
            {
                // API call succeeded
                var existingPools = await poolsApiTask;
                var existingPoolGuids = existingPools.Select(p => p.PoolGroupGuid).ToHashSet();
                
                // Mark pools that don't exist on the system as offline
                foreach (var pool in PoolGroups)
                {
                    if (!existingPoolGuids.Contains(pool.PoolGroupGuid))
                    {
                        Logger.LogWarning($"Pool {pool.GroupLabel} (ID: {pool.PoolGroupId}) exists in database but not on system. Marking as offline.");
                        pool.PoolStatus = "Offline";
                        pool.PoolEnabled = false;
                        changesMade = true;
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error retrieving pools from Agent API. Will proceed with existing database pools.");
        }

        // Update size metrics for all enabled pools
        foreach (var pool in PoolGroups.Where(p => p.PoolEnabled && !string.IsNullOrEmpty(p.MountPath)))
        {
            try
            {
                await AppDriveService.UpdatePoolSizeMetricsAsync(pool.PoolGroupGuid);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, $"Error updating size metrics for pool {pool.GroupLabel} (GUID: {pool.PoolGroupGuid})");
            }
        }

        // Collect the pool drives for filtering out of new drives
        var pooledDriveSerials = PoolGroups.SelectMany(pg => pg.Drives).Select(d => d.Serial).ToHashSet();

        // Collect the protected drives for filtering
        var protectedSerials = ProtectedDrives.Select(pd => pd.Serial).ToHashSet();

        // Process each pool group
        foreach (var pool in PoolGroups)
        {
            // Check for duplicate drive IDs
            var duplicateDriveIds = pool.Drives
                .GroupBy(d => d.Id)
                .Where(g => g.Count() > 1)
                .Select(g => g.Key)
                .ToList();

            if (duplicateDriveIds.Any())
            {
                Logger.LogWarning($"Pool {pool.GroupLabel} has duplicate drive IDs: {string.Join(", ", duplicateDriveIds)}");

                // Remove duplicate drives
                pool.Drives = pool.Drives
                .GroupBy(d => d.Id)
                .Select(g => g.First())
                .ToList();
                changesMade = true;
            }

            bool allConnected = true;
            foreach (var drive in pool.Drives)
            {
                // Find matching active drive
                var activeDrive = activeDrives.FirstOrDefault(d => d.Serial == drive.Serial);
                if (activeDrive != null)
                {
                    // Update properties if they have changed
                    if (!drive.IsConnected || drive.Vendor != activeDrive.Vendor || drive.Model != activeDrive.Model ||
                    drive.IsMounted != activeDrive.IsMounted || drive.DevPath != activeDrive.IdLink ||
                    drive.Size != activeDrive.Size)
                    {
                        drive.IsConnected = true;
                        drive.Vendor = activeDrive.Vendor;
                        drive.Model = activeDrive.Model;
                        drive.IsMounted = activeDrive.IsMounted;
                        drive.DevPath = activeDrive.IdLink;
                        drive.Size = activeDrive.Size;
                        changesMade = true;
                    }
                }
                else
                {
                    // Mark drive as disconnected if not found in active drives
                    if (drive.IsConnected)
                    {
                        drive.IsConnected = false;
                        changesMade = true;
                    }
                    allConnected = false;
                }
            }

            // Set PoolEnabled based on whether all drives are connected
            pool.AllDrivesConnected = allConnected;

            if (pool.PoolEnabled)
            {
                try
                {
                    // Skip status fetch for pools we already know are offline
                    if (pool.PoolStatus == "Offline")
                    {
                        continue;
                    }
                
                    // Fetch Pool Status with a timeout
                    var statusTask = Task.Run(() => AppDriveService.FetchPoolStatus(pool.PoolGroupId));
                    var timeoutTask = Task.Delay(5000); // 5 seconds timeout
                    
                    if (await Task.WhenAny(statusTask, timeoutTask) == timeoutTask)
                    {
                        // Status fetch timed out
                        Logger.LogWarning($"Status fetch for pool {pool.GroupLabel} timed out. Marking as Offline.");
                        if (pool.PoolStatus != "Offline")
                        {
                            pool.PoolStatus = "Offline";
                            changesMade = true;
                        }
                    }
                    else
                    {
                        // Status fetch completed
                        var status = await statusTask;
                        if (pool.PoolStatus != status)
                        {
                            pool.PoolStatus = status;
                            changesMade = true;
                        }
                    }
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, $"Error fetching pool status for pool {pool.GroupLabel}. Marking as Offline.");
                    if (pool.PoolStatus != "Offline")
                    {
                        pool.PoolStatus = "Offline";
                        changesMade = true;
                    }
                }
            }
            else
            {
                // If pool is disabled, set status to Offline
                if (pool.PoolStatus != "Offline")
                {
                    pool.PoolStatus = "Offline";
                    changesMade = true;
                }
            }
        }

        // Collect drives not in a pool or protected
        NewDrives = activeDrives
        .Where(d => !pooledDriveSerials.Contains(d.Serial) && !protectedSerials.Contains(d.Serial))
        .GroupBy(d => d.Serial)
        .Select(g => g.First())
        .ToList();

        Logger.LogInformation($"NewDrives Count after filtering: {NewDrives.Count}");

        if (changesMade)
        {
            await DbContext.SaveChangesAsync();
            Logger.LogInformation("Changes saved to the database.");
        }
    }

    // ---------------------------
    // Event Handlers
    // ---------------------------

    /// <summary>
    /// Protects a drive by its serial number.
    /// </summary>
    /// <param name="serial">The serial number of the drive to protect.</param>
    private async Task ProtectDrive(string serial)
    {
        try
        {
            Logger.LogInformation($"Attempting to protect drive with serial: {serial}");
            var result = await AppDriveService.ProtectDriveAsync(serial);
            if (result.Success)
            {
                Logger.LogInformation($"Drive {serial} protected successfully.");
                ToastService.Notify(new(ToastType.Success, $"{result.Message}"));
                await LoadDrives();
            }
            else
            {
                Logger.LogWarning($"Failed to protect drive {serial}: {result.Message}");
                ToastService.Notify(new(ToastType.Warning, $"{result.Message}"));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error protecting drive.");
            ToastService.Notify(new(ToastType.Warning, $"Error: {ex.Message}"));
        }
    }

    /// <summary>
    /// Unprotects a drive by its serial number.
    /// </summary>
    /// <param name="serial">The serial number of the drive to unprotect.</param>
    private async Task UnprotectDrive(string serial)
    {
        try
        {
            Logger.LogInformation($"Attempting to unprotect drive with serial: {serial}");
            var result = await AppDriveService.UnprotectDriveAsync(serial);
            if (result.Success)
            {
                Logger.LogInformation($"Drive {serial} unprotected successfully.");
                ToastService.Notify(new(ToastType.Success, $"{result.Message}"));
                await LoadDrives();
            }
            else
            {
                Logger.LogWarning($"Failed to unprotect drive {serial}: {result.Message}");
                ToastService.Notify(new(ToastType.Warning, $"{result.Message}"));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error unprotecting drive.");
            ToastService.Notify(new(ToastType.Warning, $"Error: {ex.Message}"));
        }
    }

    /// <summary>
    /// Toggles the selection of a drive based on its serial number.
    /// </summary>
    /// <param name="serial">The serial number of the drive to select or deselect.</param>
    private void SelectDrive(string serial)
    {
        Logger.LogInformation($"Selecting drive with serial: {serial}");
        var drive = NewDrives.FirstOrDefault(d => d.Serial == serial);
        if (drive != null)
        {
            if (SelectedDrives.Any(d => d.Serial == serial))
            {
                // Deselect the drive
                SelectedDrives.RemoveAll(d => d.Serial == serial);
                Logger.LogInformation($"Drive {serial} deselected.");
            }
            else
            {
                // Select the drive
                SelectedDrives.Add(drive);
                Logger.LogInformation($"Drive {serial} selected.");
            }
            StateHasChanged(); // Update the UI
        }
        else
        {
            Logger.LogWarning($"Drive {serial} not found.");
            ToastService.Notify(new(ToastType.Danger, $"Drive {serial} not found."));
        }
    }

    /// <summary>
    /// Checks if a drive is selected based on its serial number.
    /// </summary>
    /// <param name="serial">The serial number of the drive.</param>
    /// <returns>True if the drive is selected; otherwise, false.</returns>
    private bool IsDriveSelected(string? serial)
    {
        if (serial == null)
            return false;
        return SelectedDrives.Any(d => d.Serial == serial);
    }

    /// <summary>
    /// Opens the Create Pool modal and initializes the create pool request.
    /// </summary>
    private async Task OpenCreatePoolModal()
    {
        Logger.LogInformation("Opening Create Pool modal.");

        // Initialize CreatePoolRequest with selected drives
        CreatePoolRequest = new CreatePoolRequest
            {
                PoolLabel = "",
                DriveSerials = SelectedDrives.Select(d => d.Serial!).ToList(),
                DriveLabels = SelectedDrives.ToDictionary(d => d.Serial!, d => d.Label ?? "")
            };

        // Clear any custom drive labels
        CustomDriveLabels.Clear();

        // Pre-populate drive labels with "PoolLabel-n"
        UpdateDriveLabelsBasedOnPoolLabel();

        // Reinitialize the EditContext
        createPoolEditContext = new EditContext(CreatePoolRequest);

        // Show the modal
        await createPoolModal.ShowAsync();
    }

    /// <summary>
    /// Closes the Create Pool modal and resets the create pool request.
    /// </summary>
    private async Task CloseCreatePoolModal()
    {
        // Reset the result message
        CreatePoolResultMessage = null;

        // Hide the modal
        await createPoolModal.HideAsync();

        // Clear selected drives
        SelectedDrives.Clear();

        // Reset CreatePoolRequest to a new instance
        CreatePoolRequest = new CreatePoolRequest
            {
                PoolLabel = string.Empty,
                DriveSerials = new List<string>(),
                DriveLabels = new Dictionary<string, string>()
            };

        // Reinitialize the EditContext
        createPoolEditContext = new EditContext(CreatePoolRequest);

        // Trigger UI update
        StateHasChanged();

        // Reload drives to refresh the state
        await LoadDrives();
    }

    /// <summary>
    /// Handles the submission of the Create Pool form.
    /// </summary>
    private async Task HandleCreatePool()
    {
        Logger.LogInformation("Creating pool...");
        try
        {
            IsPoolCreationInProgress = true;
            CommandOutputs.Clear();
            CreatePoolResultMessage = null;
            CreatePoolResultSuccess = null;

            var (success, message, outputs) = await AppDriveService.CreatePoolAsync(CreatePoolRequest);
            CommandOutputs.AddRange(outputs);
            CreatePoolResultMessage = $"{message}";
            if (success)
            {
                Logger.LogInformation($"Pool created successfully: {message}");
                CreatePoolResultSuccess = true;
            }
            else
            {
                Logger.LogWarning($"Pool creation failed: {message}");
                CreatePoolResultSuccess = false;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error creating pool.");
            CreatePoolResultSuccess = false;
            CreatePoolResultMessage = $"{ex.Message}";
        }
        finally
        {
            IsPoolCreationInProgress = false;
            StateHasChanged();
        }
    }

    /// <summary>
    /// Unmounts a pool group by its instance.
    /// </summary>
    /// <param name="poolGroup">The pool group to unmount.</param>
    private async Task UnmountPool(PoolGroup poolGroup)
    {
        try
        {
            await LoadingService.ShowLoading();
            var result = await AppDriveService.UnmountPoolAsync(poolGroup.PoolGroupGuid);
            if (result.Success)
            {
                ToastService.Notify(new ToastMessage(ToastType.Success, $"{result.Message}"));
                await LoadDrives();
            }
            else
            {
                if (result.Message.Contains("target is busy", StringComparison.OrdinalIgnoreCase))
                {
                    // Fetch processes using mount point
                    currentPoolGroupGuidForUnmount = poolGroup.PoolGroupGuid;
                    var mountPoint = poolGroup.MountPath;
                    ProcessList = await AppDriveService.GetProcessesUsingMountPointAsync(mountPoint);
                    await processListModal.ShowAsync();
                }
                else
                {
                    ToastService.Notify(new ToastMessage(ToastType.Warning, $"{result.Message}"));
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Error unmounting pool '{poolGroup.GroupLabel}'.");
            ToastService.Notify(new ToastMessage(ToastType.Danger, $"Failed to unmount pool."));
        }
        finally
        {
            await LoadingService.HideLoading();
        }
    }

    /// <summary>
    /// Kills the listed processes and retries unmounting the pool.
    /// </summary>
    private async Task KillProcesses()
    {
        if (currentPoolGroupGuidForUnmount == null)
        {
            ToastService.Notify(new ToastMessage(ToastType.Warning, "No pool group selected for unmounting."));
            return;
        }

        try
        {
            await LoadingService.ShowLoading();

            var pids = ProcessList?.Select(p => p.PID).ToList() ?? new List<int>();
            if (!pids.Any())
            {
                ToastService.Notify(new ToastMessage(ToastType.Warning, "No processes to kill."));
                await processListModal.HideAsync();
                return;
            }

            var request = new KillProcessesRequest
                {
                    PoolGroupGuid = currentPoolGroupGuidForUnmount.Value,
                    Pids = pids,
                    Action = "UnmountPool"
                };

            var killResult = await AppDriveService.KillProcessesAsync(request);

            if (killResult.Success)
            {
                ToastService.Notify(new ToastMessage(ToastType.Success, killResult.Message));
                await processListModal.HideAsync();
                await LoadDrives();
            }
            else
            {
                ToastService.Notify(new ToastMessage(ToastType.Warning, killResult.Message));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error killing processes.");
            ToastService.Notify(new ToastMessage(ToastType.Danger, "Failed to kill processes."));
        }
        finally
        {
            await LoadingService.HideLoading();
            currentPoolGroupGuidForUnmount = null;
        }
    }

    /// <summary>
    /// Closes the Process List modal.
    /// </summary>
    private async Task CloseProcessListModal()
    {
        await processListModal.HideAsync();
        ProcessList = null;
        currentPoolGroupGuidForUnmount = null;
    }

    /// <summary>
    /// Removes a pool group by its instance.
    /// </summary>
    /// <param name="poolGroup">The pool group to remove.</param>
    private async Task RemovePoolGroup(PoolGroup poolGroup)
    {
        try
        {
            await LoadingService.ShowLoading();
            var result = await AppDriveService.RemovePoolGroupAsync(poolGroup.PoolGroupGuid);
            if (result.Success)
            {
                ToastService.Notify(new(ToastType.Success, $"{result.Message}"));
                await LoadDrives();
            }
            else
            {
                ToastService.Notify(new(ToastType.Warning, $"{result.Message}"));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Error removing pool '{poolGroup.GroupLabel}'.");
            ToastService.Notify(new(ToastType.Danger, $"Failed to remove pool."));
        }
        finally
        {
            await LoadingService.HideLoading();
        }
    }

    /// <summary>
    /// Mounts a pool group by its instance.
    /// </summary>
    /// <param name="poolGroup">The pool group to mount.</param>
    private async Task MountPool(PoolGroup poolGroup)
    {
        try
        {
            await LoadingService.ShowLoading();
            var result = await AppDriveService.MountPoolAsync(poolGroup.PoolGroupGuid);
            if (result.Success)
            {
                ToastService.Notify(new(ToastType.Success, $"{result.Message}"));
                await LoadDrives();
            }
            else
            {
                ToastService.Notify(new(ToastType.Warning, $"{result.Message}"));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Error mounting pool '{poolGroup.GroupLabel}'.");
            ToastService.Notify(new(ToastType.Danger, $"Failed to mount pool."));
        }
        finally
        {
            await LoadingService.HideLoading();
        }
    }

    /// <summary>
    /// Opens the Rename Pool modal and initializes the rename pool request.
    /// </summary>
    /// <param name="poolGroup">The pool group to rename.</param>
    private async Task RenamePoolGroup(PoolGroup poolGroup)
    {
        Logger.LogInformation($"Renaming pool group: {poolGroup.GroupLabel}");
        PoolToRename = poolGroup;
        RenamePoolRequest = new RenamePoolRequest
            {
                PoolGroupGuid = poolGroup.PoolGroupGuid,
                NewPoolLabel = poolGroup.GroupLabel,
                DriveLabels = poolGroup.Drives.Select(d => new DriveLabel
                {
                    DriveId = d.Id,
                    Label = d.Label
                }).ToList()
            };
        renamePoolEditContext = new EditContext(RenamePoolRequest); // Reinitialize EditContext
        await renamePoolModal.ShowAsync();
    }

    /// <summary>
    /// Handles the change event for drive labels in the rename pool form.
    /// </summary>
    /// <param name="driveId">The ID of the drive.</param>
    /// <param name="newLabel">The new label for the drive.</param>
    private Task OnRenameDriveLabelChanged(int driveId, string newLabel)
    {
        var driveLabel = RenamePoolRequest.DriveLabels.FirstOrDefault(dl => dl.DriveId == driveId);
        if (driveLabel != null)
        {
            driveLabel.Label = newLabel;
        }
        return Task.CompletedTask;
    }

    /// <summary>
    /// Forcefully adds a drive to a pool group.
    /// </summary>
    /// <param name="drive">The drive to forcefully add.</param>
    private async Task ForceAddDrive(PoolDrive drive)
    {
        try
        {
            await LoadingService.ShowLoading();
            if (drive.PoolGroup != null && drive.DevPath != null)
            {
                var result = await AppDriveService.ForceAddDriveAsync(drive.Id, drive.PoolGroup.PoolGroupGuid, drive.DevPath);
                if (result.Success)
                {
                    ToastService.Notify(new(ToastType.Success, $"{result.Message}"));
                    await LoadDrives();
                }
                else
                {
                    ToastService.Notify(new(ToastType.Warning, $"{result.Message}"));
                }
            }
            else
            {
                Logger.LogWarning("Drive PoolGroup or DevPath is null.");
                ToastService.Notify(new(ToastType.Danger, "Failed to force add drive due to missing information."));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Error force adding drive '{drive.Label}'.");
            ToastService.Notify(new(ToastType.Danger, $"Failed to force add drive."));
        }
        finally
        {
            await LoadingService.HideLoading();
        }
    }

    /// <summary>
    /// Closes the Rename Pool modal and resets the rename pool request.
    /// </summary>
    private async Task CloseRenamePoolModal()
    {
        PoolToRename = new PoolGroup(); // Initialize to avoid null reference
        RenamePoolRequest = new RenamePoolRequest
            {
                NewPoolLabel = string.Empty,
                DriveLabels = new List<Backy.Models.DriveLabel>()
            };
        await renamePoolModal.HideAsync();
    }

    /// <summary>
    /// Handles the submission of the Rename Pool form.
    /// </summary>
    private async Task HandleRenamePool()
    {
        Logger.LogInformation("Renaming pool...");
        try
        {
            IsRenameInProgress = true;
            RenameCommandOutputs.Clear();
            RenameResultMessage = null;
            RenameResultSuccess = null;

            var (success, message) = await AppDriveService.RenamePoolGroupAsync(RenamePoolRequest);
            RenameResultMessage = message;

            if (success)
            {
                Logger.LogInformation($"Pool renamed successfully: {message}");
                RenameResultSuccess = true;
            }
            else
            {
                Logger.LogWarning($"Pool renaming failed: {message}");
                RenameResultSuccess = false;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error renaming pool.");
            RenameResultSuccess = false;
            RenameResultMessage = ex.Message;
        }
        finally
        {
            IsRenameInProgress = false;
            StateHasChanged();
        }
    }

    // ---------------------------
    // Drive Selection and Pool Creation Helpers
    // ---------------------------

    /// <summary>
    /// Updates drive labels based on the current pool label.
    /// Only updates labels that have not been manually set.
    /// </summary>
    private void UpdateDriveLabelsBasedOnPoolLabel()
    {
        if (string.IsNullOrWhiteSpace(CreatePoolRequest.PoolLabel))
            return;

        int counter = 1;
        foreach (var serial in CreatePoolRequest.DriveSerials)
        {
            if (!CustomDriveLabels.Contains(serial))
            {
                CreatePoolRequest.DriveLabels[serial] = $"{CreatePoolRequest.PoolLabel}-{counter}";
                counter++;
            }
        }
    }

    /// <summary>
    /// Event handler when the pool label is changed.
    /// Updates drive labels accordingly.
    /// </summary>
    /// <param name="e">The change event arguments.</param>
    private async Task HandlePoolLabelChanged(ChangeEventArgs e)
    {
        string newPoolLabel = e.Value?.ToString() ?? string.Empty;
        CreatePoolRequest.PoolLabel = newPoolLabel;
        UpdateDriveLabelsBasedOnPoolLabel();
        await InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// Event handler when a drive label is changed manually.
    /// Marks the drive label as custom to prevent automatic overrides.
    /// </summary>
    /// <param name="serial">The serial number of the drive.</param>
    /// <param name="newLabel">The new label for the drive.</param>
    private Task OnDriveLabelChanged(string serial, string newLabel)
    {
        if (!string.IsNullOrWhiteSpace(newLabel))
        {
            CustomDriveLabels.Add(serial);
            CreatePoolRequest.DriveLabels[serial] = newLabel;
        }
        else
        {
            CustomDriveLabels.Remove(serial);
            // Re-populate with default if pool label exists
            if (!string.IsNullOrWhiteSpace(CreatePoolRequest.PoolLabel))
            {
                int driveIndex = CreatePoolRequest.DriveSerials.IndexOf(serial) + 1;
                CreatePoolRequest.DriveLabels[serial] = $"{CreatePoolRequest.PoolLabel}-{driveIndex}";
            }
        }
        return Task.CompletedTask;
    }

    /// <summary>
    /// Handles the completion of a pool creation operation.
    /// </summary>
    /// <param name="poolGroupGuid">The GUID of the completed pool.</param>
    private async Task HandlePoolCreationComplete(Guid poolGroupGuid)
    {
        Logger.LogInformation("Pool creation completed for pool with GUID: {PoolGroupGuid}", poolGroupGuid);
        
        // No need to show a toast notification as the CreatingPoolCard already shows one
        
        // Refresh the drives and pools
        await LoadDrives();
        
        // Force state update
        await InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// Handles the cancellation of a pool creation operation.
    /// </summary>
    /// <param name="poolGroupGuid">The GUID of the cancelled pool.</param>
    private async Task HandlePoolCreationCancel(Guid poolGroupGuid)
    {
        Logger.LogInformation("Pool creation cancelled for pool with GUID: {PoolGroupGuid}", poolGroupGuid);
        
        // Optionally remove the pool from the database since it was cancelled
        var poolToRemove = PoolGroups.FirstOrDefault(p => p.PoolGroupGuid == poolGroupGuid);
        if (poolToRemove != null)
        {
            try
            {
                DbContext.PoolGroups.Remove(poolToRemove);
                await DbContext.SaveChangesAsync();
                ToastService.Notify(new ToastMessage(ToastType.Warning, $"Pool creation '{poolToRemove.GroupLabel}' cancelled."));
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error removing cancelled pool from database");
                ToastService.Notify(new ToastMessage(ToastType.Danger, "Failed to remove cancelled pool from database."));
            }
        }
        
        // Refresh the drives and pools
        await LoadDrives();
        
        // Force state update
        await InvokeAsync(StateHasChanged);
    }
}
