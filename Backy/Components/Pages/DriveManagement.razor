@page "/DriveManagement"
@inject ApplicationDbContext DbContext
@inject ILogger<DriveManagement> Logger
@inject ILoadingService LoadingService
@inject IDriveService DriveService
@rendermode InteractiveServer

<PageTitle>Drive Catalog - Backy</PageTitle>

<div class="d-flex justify-content-between align-items-center mb-4">
    <h1>Drive Catalog</h1>
    <!-- Refresh Button / Create Pool -->
    <span>
        <button class="btn btn-secondary" @onclick="LoadDrives">Refresh</button>
        @if (SelectedDrives != null && SelectedDrives.Any())
        {
            <Button Color="ButtonColor.Primary" @onclick="OpenCreatePoolModal"> Create Pool </Button>
        }
        else
        {
            <Button Color="ButtonColor.Primary" Disabled="true"> Create Pool </Button>
        }
    </span>
</div>

<!-- New Drives -->
@if (NewDrives != null && NewDrives.Any())
{
    <h2>New Drives</h2>
    <div>
    @foreach (var drive in NewDrives)
        {
            <div class="col">
                <NewDriveCard Model="@drive" OnProtect="@ProtectDrive" OnSelect="@SelectDrive"
                    IsSelected="@IsDriveSelected(drive.Serial)" />
            </div>
        }
    </div>
}
else
{
    <p>No new drives found.</p>
}

<!-- Pool Groups -->
@if (PoolGroups != null && PoolGroups.Any())
{
    @foreach (var pool in PoolGroups)
    {
        <PoolGroupDriveCard Model="@pool" OnUnmountPool="@UnmountPool" OnRemovePoolGroup="@RemovePoolGroup"
    OnMountPool="@MountPool" OnRenamePoolGroup="@RenamePoolGroup" />
    }
}

<!-- Protected Drives -->
@if (ProtectedDrives != null && ProtectedDrives.Any())
{
    <h2>Protected Drives</h2>
    <div>
    @foreach (var drive in ProtectedDrives)
        {
            <div class="col">
                <ProtectedDriveCard Model="@drive" OnUnprotect="@UnprotectDrive" />
            </div>
        }
    </div>
}

<!-- Create Pool Modal -->
@if (isCreatePoolModalOpen)
{
    <Modal Title="Create Pool" @bind-Visible="isCreatePoolModalOpen">
    @if (!isCreatePoolResultVisible)
        {
            <EditForm Model="@CreatePoolRequest" OnValidSubmit="HandleCreatePool">
                <DataAnnotationsValidator />
                <ValidationSummary />

                <div class="mb-3">
                    <label for="poolLabel" class="form-label">Pool Label</label>
                    <InputText id="poolLabel" class="form-control" @bind-Value="CreatePoolRequest.PoolLabel" required />
                    <ValidationMessage For="@(() => CreatePoolRequest.PoolLabel)" />
                </div>

                <!-- Drive Labels -->
                @foreach (var drive in SelectedDrives)
                {
                    <div class="mb-3">
                        <label class="form-label">Drive Label (@drive.Serial)</label>
                        <InputText class="form-control" @bind-Value="CreatePoolRequest.DriveLabels[drive.Serial]" />
                    </div>
                }

                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" @onclick="CloseCreatePoolModal">Close</button>
                    <button type="submit" class="btn btn-primary">Create Pool</button>
                </div>
            </EditForm>
        }
        else
        {
            <div>
                <h5>@CreatePoolResultMessage</h5>
                <pre class="console-output">@string.Join("\n", CommandOutputs)</pre>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" @onclick="CloseCreatePoolModal">Close</button>
                </div>
            </div>
        }
        </Modal>
}

<!-- Rename Pool Modal -->
@if (isRenamePoolModalOpen)
{
    <Modal Title="Rename Pool" @bind-Visible="isRenamePoolModalOpen">
    <EditForm Model="@RenamePoolRequest" OnValidSubmit="HandleRenamePool">
        <DataAnnotationsValidator />
        <ValidationSummary />

        <div class="mb-3">
            <label for="newPoolLabel" class="form-label">New Pool Label</label>
            <InputText id="newPoolLabel" class="form-control" @bind-Value="RenamePoolRequest.NewPoolLabel" required />
            <ValidationMessage For="@(() => RenamePoolRequest.NewPoolLabel)" />
        </div>

        <!-- Drive Labels -->
        @foreach (var drive in PoolToRename.Drives)
            {
                <div class="mb-3">
                    <label class="form-label">Drive Label (@drive.Serial)</label>
                    <InputText class="form-control" @bind-Value="RenamePoolRequest.DriveLabels[drive.Id]" />
                </div>
            }

            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" @onclick="CloseRenamePoolModal">Close</button>
                <button type="submit" class="btn btn-primary">Rename Pool</button>
            </div>
        </EditForm>
    </Modal>
}

@code {
    [Inject] protected ToastService ToastService { get; set; } = default!;
    private List<PoolGroup> PoolGroups { get; set; } = new List<PoolGroup>();
    private List<Drive> NewDrives { get; set; } = new List<Drive>();
    private List<ProtectedDrive> ProtectedDrives { get; set; } = new List<ProtectedDrive>();
    private List<Drive> SelectedDrives { get; set; } = new List<Drive>();
    private CreatePoolRequest CreatePoolRequest { get; set; } = new CreatePoolRequest
        {
            PoolLabel = string.Empty,
            DriveSerials = new List<string>(),
            DriveLabels = new Dictionary<string, string?>()
        };
    private bool isCreatePoolModalOpen = false;
    private bool isCreatePoolResultVisible = false; // New flag for displaying results
    private bool isRenamePoolModalOpen = false;
    private PoolGroup PoolToRename { get; set; } = new PoolGroup();
    private RenamePoolRequest RenamePoolRequest { get; set; } = new RenamePoolRequest
        {
            NewPoolLabel = string.Empty,
            DriveLabels = new Dictionary<int, string?>()
        };
    private List<string> CommandOutputs { get; set; } = new List<string>(); // To store command outputs
    private string CreatePoolResultMessage { get; set; } = string.Empty;

    protected override async Task OnInitializedAsync()
    {
        await LoadDrives();
    }

    private async Task LoadDrives()
    {
        try
        {
            await LoadingService.ShowLoading();
            await OrganizeDrives();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading drives.");
            ToastService.Notify(new(ToastType.Danger, $"Error: {ex.Message}."));
        }
        finally
        {
            await LoadingService.HideLoading();
        }
    }

    private async Task OrganizeDrives()
    {
        var activeDrives = await DriveService.UpdateActiveDrivesAsync();
        Logger.LogInformation($"Found {activeDrives.Count} active drives.");

        PoolGroups = await DbContext.PoolGroups.Include(pg => pg.Drives).ToListAsync();
        Logger.LogInformation($"Loaded {PoolGroups.Count} pool groups from the database.");

        ProtectedDrives = await DbContext.ProtectedDrives.ToListAsync();
        Logger.LogInformation($"Loaded {ProtectedDrives.Count} protected drives from the database.");

        // Update connected status and properties for drives in pools
        foreach (var pool in PoolGroups)
        {
            bool allConnected = true;
            foreach (var drive in pool.Drives)
            {
                // Find matching active drive
                var activeDrive = activeDrives.FirstOrDefault(d => d.Serial == drive.Serial);
                if (activeDrive != null)
                {
                    // Update properties
                    drive.IsConnected = true;
                    drive.Vendor = activeDrive.Vendor;
                    drive.Model = activeDrive.Model;
                    drive.IsMounted = activeDrive.IsMounted;
                    drive.DevPath = activeDrive.IdLink;
                    drive.Size = activeDrive.Size;
                }
                else
                {
                    drive.IsConnected = false;
                    allConnected = false;
                }
            }

            // Set PoolEnabled based on whether all drives are connected
            pool.AllDrivesConnected = allConnected;

            if (pool.PoolEnabled)
            {
                // Fetch Pool Status
                string status = DriveService.FetchPoolStatus(pool.PoolGroupId);
                if (pool.PoolStatus != status)
                {
                    pool.PoolStatus = status;
                    await DbContext.SaveChangesAsync();
                }

                if (!string.IsNullOrEmpty(pool.MountPath))
                {
                    var (size, used, available, usePercent) = DriveService.GetMountPointSize(pool.MountPath);

                    if (size > 0)
                    {
                        pool.Size = size;
                        pool.Used = used;
                        pool.Available = available;
                        pool.UsePercent = usePercent;
                        await DbContext.SaveChangesAsync();
                    }
                }
            }
        }

        // NewDrives: drives that are active but not in any pool and not protected
        var pooledDriveSerials = PoolGroups.SelectMany(p => p.Drives).Select(d => d.Serial).ToHashSet();
        var protectedSerials = ProtectedDrives.Select(pd => pd.Serial).ToHashSet();
        NewDrives = activeDrives.Where(d => !pooledDriveSerials.Contains(d.Serial) &&
        !protectedSerials.Contains(d.Serial)).ToList();
    }

    private async Task ProtectDrive(string serial)
    {
        try
        {
            Logger.LogInformation($"Attempting to protect drive with serial: {serial}");
            var result = await DriveService.ProtectDriveAsync(serial);
            if (result.Success)
            {
                Logger.LogInformation($"Drive {serial} protected successfully.");
                ToastService.Notify(new(ToastType.Success, $"{result.Message}"));
                await LoadDrives();
            }
            else
            {
                Logger.LogWarning($"Failed to protect drive {serial}: {result.Message}");
                ToastService.Notify(new(ToastType.Warning, $"{result.Message}"));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error protecting drive.");
            ToastService.Notify(new(ToastType.Warning, $"Error: {ex.Message}"));
        }
    }

    private async Task UnprotectDrive(string serial)
    {
        try
        {
            Logger.LogInformation($"Attempting to unprotect drive with serial: {serial}");
            var result = await DriveService.UnprotectDriveAsync(serial);
            if (result.Success)
            {
                Logger.LogInformation($"Drive {serial} unprotected successfully.");
                ToastService.Notify(new(ToastType.Success, $"{result.Message}"));
                await LoadDrives();
            }
            else
            {
                Logger.LogWarning($"Failed to unprotect drive {serial}: {result.Message}");
                ToastService.Notify(new(ToastType.Warning, $"{result.Message}"));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error unprotecting drive.");
            ToastService.Notify(new(ToastType.Warning, $"Error: {ex.Message}"));
        }
    }

    private async Task SelectDrive(string serial)
    {
        Logger.LogInformation($"Selecting drive with serial: {serial}");
        var drive = NewDrives.FirstOrDefault(d => d.Serial == serial);
        if (drive != null)
        {
            if (SelectedDrives.Any(d => d.Serial == serial))
            {
                // Deselect the drive
                SelectedDrives.RemoveAll(d => d.Serial == serial);
                Logger.LogInformation($"Drive {serial} deselected.");
            }
            else
            {
                // Select the drive
                SelectedDrives.Add(drive);
                Logger.LogInformation($"Drive {serial} selected.");
            }
            StateHasChanged(); // Update the UI
        }
        else
        {
            Logger.LogWarning($"Drive {serial} not found.");
            ToastService.Notify(new(ToastType.Danger, $"Drive {serial} not found."));
        }
    }

    private bool IsDriveSelected(string? serial)
    {
        if (serial == null)
            return false;
        return SelectedDrives.Any(d => d.Serial == serial);
    }


    private void OpenCreatePoolModal()
    {
        CreatePoolRequest = new CreatePoolRequest
            {
                PoolLabel = "",
                DriveSerials = SelectedDrives.Select(d => d.Serial).ToList(),
                DriveLabels = SelectedDrives.ToDictionary(d => d.Serial, d => d.Label ?? "")
            };
        isCreatePoolModalOpen = true;
    }

    private void CloseCreatePoolModal()
    {
        isCreatePoolModalOpen = false;
        isCreatePoolResultVisible = false;
        SelectedDrives.Clear();
        CommandOutputs.Clear();
        CreatePoolResultMessage = string.Empty;
    }

    private async Task HandleCreatePool()
    {
        try
        {
            await LoadingService.ShowLoading();
            var (success, message, outputs) = await DriveService.CreatePoolAsync(CreatePoolRequest);

            if (success)
            {
                // Display the command outputs in the modal
                CommandOutputs = outputs;
                CreatePoolResultMessage = message;
                isCreatePoolResultVisible = true;
            }
            else
            {
                // Display the error and outputs
                CommandOutputs = outputs;
                CreatePoolResultMessage = message;
                isCreatePoolResultVisible = true;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error creating pool.");
            ToastService.Notify(new(ToastType.Danger, $"Failed to create pool."));
        }
        finally
        {
            await LoadingService.HideLoading();
        }
    }

    private async Task UnmountPool(PoolGroup poolGroup)
    {
        try
        {
            await LoadingService.ShowLoading();
            var result = await DriveService.UnmountPoolAsync(poolGroup.PoolGroupGuid);
            if (result.Success)
            {
                ToastService.Notify(new(ToastType.Success, $"{result.Message}"));
                await LoadDrives();
            }
            else
            {
                ToastService.Notify(new(ToastType.Warning, $"{result.Message}"));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Error unmounting pool '{poolGroup.GroupLabel}'.");
            ToastService.Notify(new(ToastType.Danger, $"Failed to unmount pool."));
        }
        finally
        {
            await LoadingService.HideLoading();
        }
    }

    private async Task RemovePoolGroup(PoolGroup poolGroup)
    {
        try
        {
            await LoadingService.ShowLoading();
            var result = await DriveService.RemovePoolGroupAsync(poolGroup.PoolGroupGuid);
            if (result.Success)
            {
                ToastService.Notify(new(ToastType.Success, $"{result.Message}"));
                await LoadDrives();
            }
            else
            {
                ToastService.Notify(new(ToastType.Warning, $"{result.Message}"));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Error removing pool '{poolGroup.GroupLabel}'.");
            ToastService.Notify(new(ToastType.Danger, $"Failed to remove pool."));
        }
        finally
        {
            await LoadingService.HideLoading();
        }
    }

    private async Task MountPool(PoolGroup poolGroup)
    {
        try
        {
            await LoadingService.ShowLoading();
            var result = await DriveService.MountPoolAsync(poolGroup.PoolGroupGuid);
            if (result.Success)
            {
                ToastService.Notify(new(ToastType.Success, $"{result.Message}"));
                await LoadDrives();
            }
            else
            {
                ToastService.Notify(new(ToastType.Warning, $"{result.Message}"));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Error mounting pool '{poolGroup.GroupLabel}'.");
            ToastService.Notify(new(ToastType.Danger, $"Failed to mount pool."));
        }
        finally
        {
            await LoadingService.HideLoading();
        }
    }

    private async Task RenamePoolGroup(PoolGroup poolGroup)
    {
        Logger.LogInformation($"Renaming pool group: {poolGroup.GroupLabel}");
        isRenamePoolModalOpen = true;
        PoolToRename = poolGroup;
        RenamePoolRequest = new RenamePoolRequest
            {
                PoolGroupGuid = poolGroup.PoolGroupGuid,
                NewPoolLabel = poolGroup.GroupLabel,
                DriveLabels = poolGroup.Drives.ToDictionary(d => d.Id, d => (string?)d.Label)
            };
    }

    private void CloseRenamePoolModal()
    {
        isRenamePoolModalOpen = false;
        PoolToRename = new PoolGroup(); // Initialize to avoid null reference
        RenamePoolRequest = new RenamePoolRequest
            {
                NewPoolLabel = string.Empty,
                DriveLabels = new Dictionary<int, string?>()
            };
    }

    private async Task HandleRenamePool()
    {
        if (RenamePoolRequest == null)
        {
            ToastService.Notify(new(ToastType.Danger, $"Invalid rename request."));
            return;
        }
        try
        {
            // Call the service to rename the pool
            var result = await DriveService.RenamePoolGroupAsync(RenamePoolRequest);

            if (result.Success)
            {
                ToastService.Notify(new(ToastType.Success, $"{result.Message}"));
                isRenamePoolModalOpen = false;
                await LoadDrives();
            }
            else
            {
                ToastService.Notify(new(ToastType.Warning, $"{result.Message}"));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error renaming pool.");
            ToastService.Notify(new(ToastType.Danger, $"Failed to rename pool."));
        }
    }
}
