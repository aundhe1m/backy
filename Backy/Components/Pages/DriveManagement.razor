@page "/DriveManagement"
@inject ApplicationDbContext DbContext
@inject ILogger<DriveManagement> Logger
@inject ILoadingService LoadingService
@inject IDriveService DriveService
@inject NavigationManager NavigationManager
@inject ModalService ModalService
@inject ToastService ToastService
@rendermode InteractiveServer

<PageTitle>Drive Catalog - Backy</PageTitle>

<div class="d-flex justify-content-between align-items-center mb-4">
    <h1>Drive Catalog</h1>
    <!-- Search Bar -->
    <div class="input-group" style="max-width: 400px;">
        <input type="text" class="form-control search-bar" placeholder="Search drives..." @bind="searchQuery">
        <span class="input-group-text">
            <img src="/icons/search.svg" alt="Search Icon" class="search-icon search-bar theme-icon">
        </span>
    </div>
    <!-- Refresh Button / Create Pool -->
    <span>
        <Tooltip Title="Refresh" Color="TooltipColor.Dark">
            <button class="btn btn-info" @onclick="LoadDrives">
                <img src="/icons/arrow-clockwise.svg" alt="Refresh" style="height: 24px;" class="theme-icon" />
            </button>
        </Tooltip>

        <Tooltip Title="Create Pool Group" Color="TooltipColor.Dark">
            @if (SelectedDrives != null && SelectedDrives.Any())
            {
                <button class="btn btn-success" @onclick="OpenCreatePoolModal">
                    <img src="/icons/plus-square-fill.svg" alt="Create Pool Group" style="height: 24px;"
                        class="theme-icon" />
                </button>
            }
            else
            {
                <button class="btn btn-success" disabled>
                    <img src="/icons/plus-square.svg" alt="Create Pool Group" style="height: 24px;" class="theme-icon" />
                </button>
            }
        </Tooltip>
    </span>
</div>

<!-- New Drives -->
<div class="drive-management-container">
    <h2 class="section-title">New Drives</h2>
    @if (FilteredNewDrives != null && FilteredNewDrives.Any())
    {
        <div class="row">
            @foreach (var drive in FilteredNewDrives)
            {
                <div class="col-md-12">
                    <NewDriveCard Model="@drive" OnProtect="@ProtectDrive" OnSelect="@SelectDrive"
                        IsSelected="@IsDriveSelected(drive.Serial!)" />
                </div>
            }
        </div>
    }
    else
    {
        <p>No new drives found.</p>
    }
</div>

<!-- Pool Groups -->
<div class="drive-management-container">
    <h2 class="section-title">Pool Groups</h2>

    @if (FilteredPoolGroups != null && FilteredPoolGroups.Any())
    {
        <div class="row">
            @foreach (var pool in FilteredPoolGroups)
            {
                <div class="col-md-12">
                    <PoolGroupDriveCard @key="pool.PoolGroupId" Model="@pool" OnUnmountPool="@UnmountPool"
                        OnRemovePoolGroup="@RemovePoolGroup" OnMountPool="@MountPool" OnRenamePoolGroup="@RenamePoolGroup"
                        OnForceAddDrive="@ForceAddDrive" />
                </div>
            }
        </div>
    }
</div>

<!-- Protected Drives -->
<div class="drive-management-container">
    <h2 class="section-title">Protected Drives</h2>
    @if (ProtectedDrives != null && ProtectedDrives.Any())
    {
        <div class="row">
            @foreach (var drive in ProtectedDrives)
            {
                <div class="col-md-12">
                    <ProtectedDriveCard Model="@drive" OnUnprotect="@UnprotectDrive" />
                </div>
            }
        </div>
    }
</div>

<!-- Create Pool Modal -->
<Modal @ref="createPoolModal" Title="Create Pool" Size="ModalSize.Large">
    <BodyTemplate>
        @if (IsPoolCreationInProgress)
        {
            <h3>Creating pool...</h3>
        }
        else if (CreatePoolResultMessage != null)
        {
            <div class="pool-result-message">
                <pre>@string.Join("\n", CommandOutputs)<br></pre>
            </div>
            <br>
            @if (CreatePoolResultSuccess == true)
            {
                <Alert Color="AlertColor.Success">
                    <span style="display: flex;">
                        <img src="/icons/check-circle-fill-green.svg" alt="Success Icon"
                            style="height: 24px; margin-right: 8px;" />
                        <h5 style="margin: 0;">Success</h5>
                    </span>
                    <hr style="border: 1px solid gray; margin-top: 8px; margin-bottom: 8px;" />
                    <div>
                        @CreatePoolResultMessage
                    </div>
                </Alert>
            }
            else
            {
                <Alert Color="AlertColor.Danger">
                    <span style="display: flex;">
                        <img src="/icons/exclamation-triangle-fill-red.svg" alt="Error Icon"
                            style="height: 24px; margin-right: 8px;" />
                        <h5>Error</h5>
                    </span>
                    <hr style="border: 1px solid gray; margin-top: 8px; margin-bottom: 8px;" />
                    <div>
                        @CreatePoolResultMessage
                    </div>
                </Alert>
            }
        }
        else
        {
            <EditForm id="createPoolForm" EditContext="@createPoolEditContext" OnValidSubmit="HandleCreatePool">
                <DataAnnotationsValidator />
                <ValidationSummary />

                <!-- Pool Label Input with Icon -->
                <div class="mb-3">
                    <h5>Drive Labels</h5>
                    <div class="d-flex align-items-center">
                        <img src="/icons/hdd-rack.svg" alt="Pool Icon" style="height: 24px; margin-right: 8px;"
                            class="theme-icon" />
                        <div class="flex-grow-1 d-flex align-items-center">
                            <label for="poolLabel" class="form-label me-2">Pool Label:</label>
                            <InputText placeholder="Enter pool label" id="poolLabel" class="form-control flex-grow-1"
                                @bind-Value="CreatePoolRequest.PoolLabel" required @oninput="HandlePoolLabelChanged" />
                            <ValidationMessage For="@(() => CreatePoolRequest.PoolLabel)" />
                        </div>
                    </div>
                </div>

                <!-- Drive Labels using PoolDriveLabelCard -->
                <div class="drive-labels-section">
                    <h5>Drive Labels</h5>
                    @foreach (var drive in SelectedDrives ?? Enumerable.Empty<Drive>())
                    {
                        var driveSerial = drive.Serial!;
                        <PoolDriveLabelCard Model="@drive" DriveLabel="@CreatePoolRequest.DriveLabels[driveSerial]"
                            OnLabelChangedCallback="@(async (newLabel) => await OnDriveLabelChanged(driveSerial, newLabel))" />
                    }
                </div>
            </EditForm>
        }
    </BodyTemplate>
    <FooterTemplate>
        @if (IsPoolCreationInProgress)
        {
            <Button Color="ButtonColor.Secondary" Disabled="true">
                <Spinner Type="SpinnerType.Dots" Class="me-3" Color="SpinnerColor.Light" />
                Creating...
            </Button>
        }
        else if (CreatePoolResultMessage != null)
        {
            <Button Color="ButtonColor.Secondary" @onclick="CloseCreatePoolModal">Close</Button>
        }
        else
        {
            <Button Type="ButtonType.Button" Color="ButtonColor.Secondary" @onclick="CloseCreatePoolModal">Cancel</Button>
            <Button Type="ButtonType.Submit" Color="ButtonColor.Primary" Form="createPoolForm">Create Pool</Button>

        }
    </FooterTemplate>
</Modal>

<!-- Rename Pool Modal -->
<Modal @ref="renamePoolModal" Title="Rename Pool" Size="ModalSize.Large">
    <BodyTemplate>
        @if (IsRenameInProgress)
        {
            <h3>Renaming pool...</h3>
        }
        else if (RenameResultMessage != null)
        {
            @if (RenameResultSuccess == true)
            {
                <Alert Color="AlertColor.Success">
                    <span style="display: flex;">
                        <img src="/icons/check-circle-fill-green.svg" alt="Success Icon"
                            style="height: 24px; margin-right: 8px;" />
                        <h5 style="margin: 0;">Success</h5>
                    </span>
                    <hr style="border: 1px solid gray; margin-top: 8px; margin-bottom: 8px;" />
                    <div>
                        @RenameResultMessage
                    </div>
                </Alert>
            }
            else
            {
                <Alert Color="AlertColor.Danger">
                    <span style="display: flex;">
                        <img src="/icons/exclamation-triangle-fill-red.svg" alt="Error Icon"
                            style="height: 24px; margin-right: 8px;" />
                        <h5>Error</h5>
                    </span>
                    <hr style="border: 1px solid gray; margin-top: 8px; margin-bottom: 8px;" />
                    <div>
                        @RenameResultMessage
                    </div>
                </Alert>
            }
        }
        else
        {
            <EditForm id="renamePoolForm" EditContext="@renamePoolEditContext" OnValidSubmit="HandleRenamePool">
                <DataAnnotationsValidator />
                <ValidationSummary />
                <div class="mb-3">
                    <h5>New Pool Label</h5>
                    <div class="d-flex align-items-center">
                        <img src="/icons/pencil-square.svg" alt="Rename Icon" style="height: 24px; margin-right: 8px;"
                            class="theme-icon" />
                        <div class="flex-grow-1">
                            <InputText id="newPoolLabel" class="form-control" @bind-Value="RenamePoolRequest.NewPoolLabel"
                                required placeholder="Enter new pool label" />
                            <ValidationMessage For="@(() => RenamePoolRequest.NewPoolLabel)" />
                        </div>
                    </div>
                </div>

                <!-- Drive Labels using PoolDriveLabelCard -->
                <div class="drive-labels-section">
                    <h5>Drive Labels</h5>
                    @foreach (var driveLabel in RenamePoolRequest.DriveLabels)
                    {
                        var drive = GetDriveById(driveLabel.DriveId);
                        if (drive != null)
                        {
                            <PoolDriveLabelCard Model="@drive" DriveLabel="@driveLabel.Label"
                                OnLabelChangedCallback="@(async (newLabel) => await OnRenameDriveLabelChanged(driveLabel.DriveId, newLabel))" />
                        }
                    }
                </div>
            </EditForm>
        }
    </BodyTemplate>
    <FooterTemplate>
        @if (IsRenameInProgress)
        {
            <Button Color="ButtonColor.Secondary" Disabled="true">
                <Spinner Type="SpinnerType.Dots" Class="me-3" Color="SpinnerColor.Light" />
                Renaming...
            </Button>
        }
        else if (RenameResultMessage != null)
        {
            <Button Color="ButtonColor.Secondary" @onclick="CloseRenamePoolModal">Close</Button>
        }
        else
        {
            <Button Type="ButtonType.Button" Color="ButtonColor.Secondary" @onclick="CloseRenamePoolModal">Cancel</Button>
            <Button Type="ButtonType.Submit" Color="ButtonColor.Primary" Form="renamePoolForm">Rename Pool</Button>
        }
    </FooterTemplate>
</Modal>

<!-- Process List Modal -->
<Modal @ref="processListModal" Title="Processes Preventing Unmount" Size="ModalSize.Large">
    <BodyTemplate>
        @if (ProcessList == null)
        {
            <p>Loading processes...</p>
        }
        else if (!ProcessList.Any())
        {
            <p>No processes are currently using the mount point.</p>
        }
        else
        {
            <p>The following processes are preventing the pool from being unmounted:</p>
            <table class="table table-striped">
            <thead>
                <tr>
                    <th>PID</th>
                    <th>Command</th>
                    <th>User</th>
                    <th>Name</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var process in ProcessList)
                    {
                        <tr>
                            <td>@process.PID</td>
                            <td>@process.Command</td>
                            <td>@process.User</td>
                            <td>@process.Name</td>
                        </tr>
                    }
                </tbody>
            </table>
            <p>Do you want to kill these processes and retry unmounting the pool?</p>
        }
    </BodyTemplate>
    <FooterTemplate>
        @if (ProcessList != null && ProcessList.Any())
        {
            <Button Color="ButtonColor.Danger" @onclick="KillProcesses">Kill Processes</Button>
            <Button Color="ButtonColor.Secondary" @onclick="CloseProcessListModal">Cancel</Button>
        }
        else
        {
            <Button Color="ButtonColor.Secondary" @onclick="CloseProcessListModal">Close</Button>
        }
    </FooterTemplate>
</Modal>

@code {
    private List<PoolGroup> PoolGroups { get; set; } = new List<PoolGroup>();
    private List<Drive> NewDrives { get; set; } = new List<Drive>();
    private List<ProtectedDrive> ProtectedDrives { get; set; } = new List<ProtectedDrive>();
    private List<Drive> SelectedDrives { get; set; } = new List<Drive>();

    // Updated CreatePoolRequest to initialize DriveLabels
    private CreatePoolRequest CreatePoolRequest { get; set; } = new CreatePoolRequest
        {
            PoolLabel = string.Empty,
            DriveSerials = new List<string>(),
            DriveLabels = new Dictionary<string, string>()
        };

    private HashSet<string> CustomDriveLabels { get; set; } = new HashSet<string>();

    private PoolGroup PoolToRename { get; set; } = new PoolGroup();
    private EditContext? createPoolEditContext;
    private EditContext? renamePoolEditContext;
    private RenamePoolRequest RenamePoolRequest { get; set; } = new RenamePoolRequest
        {
            NewPoolLabel = string.Empty,
            DriveLabels = new List<Backy.Models.DriveLabel>()
        };
    private List<string> CommandOutputs { get; set; } = new List<string>(); // To store command outputs
    private string? CreatePoolResultMessage { get; set; } = null;
    private bool? CreatePoolResultSuccess { get; set; } = null;

    private Modal createPoolModal = default!;
    private Modal renamePoolModal = default!;

    private Modal processListModal = default!;
    private List<ProcessInfo>? ProcessList { get; set; } = null;
    private Guid? currentPoolGroupGuidForUnmount = null;

    private bool IsRenameInProgress { get; set; } = false;
    private string? RenameResultMessage { get; set; } = null;
    private bool? RenameResultSuccess { get; set; } = null;
    private List<string> RenameCommandOutputs { get; set; } = new List<string>();

    private bool IsPoolCreationInProgress { get; set; } = false;

    private string searchQuery = string.Empty;

    private Drive? GetDriveById(int driveId)
    {
        foreach (var poolGroup in PoolGroups)
        {
            var drive = poolGroup.Drives.FirstOrDefault(d => d.Id == driveId)?.ToDrive();
            if (drive != null)
                return drive;
        }
        return null;
    }

    private IEnumerable<Drive> FilteredNewDrives => NewDrives.Where(d => IsDriveMatch(d));
    private IEnumerable<PoolGroup> FilteredPoolGroups => PoolGroups.Where(pg => IsPoolGroupMatch(pg));
    private IEnumerable<ProtectedDrive> FilteredProtectedDrives => ProtectedDrives.Where(pd => IsDriveMatch(new Drive
        {
            Name = pd.Name,
            Label = pd.Label,
            Vendor = pd.Vendor,
            Model = pd.Model,
            Serial = pd.Serial
        }));

    private bool IsDriveMatch(Drive drive)
    {
        if (string.IsNullOrWhiteSpace(searchQuery))
        {
            Logger.LogInformation($"IsDriveMatch: searchQuery is empty. Drive {drive.Serial} matches.");
            return true;
        }

        var query = searchQuery.ToLowerInvariant();
        bool match = (drive.Name?.ToLowerInvariant().Contains(query) ?? false)
        || (drive.Label?.ToLowerInvariant().Contains(query) ?? false)
        || (drive.Vendor?.ToLowerInvariant().Contains(query) ?? false)
        || (drive.Model?.ToLowerInvariant().Contains(query) ?? false)
        || (drive.Serial?.ToLowerInvariant().Contains(query) ?? false);

        Logger.LogInformation($"IsDriveMatch: Drive {drive.Serial} match status: {match}");
        return match;
    }

    private bool IsPoolGroupMatch(PoolGroup poolGroup)
    {
        if (string.IsNullOrWhiteSpace(searchQuery))
            return true;
        var query = searchQuery.ToLowerInvariant();
        return (poolGroup.GroupLabel?.ToLowerInvariant().Contains(query) ?? false)
        || poolGroup.Drives.Any(d => IsDriveMatch(new Drive
            {
                Label = d.Label,
                Vendor = d.Vendor,
                Model = d.Model,
                Serial = d.Serial
            }));
    }

    protected override async Task OnInitializedAsync()
    {
        createPoolEditContext = new EditContext(CreatePoolRequest);
        renamePoolEditContext = new EditContext(RenamePoolRequest);
        Logger.LogInformation("Drive Management page initialized.");
        await LoadDrives();
    }

    private async Task LoadDrives()
    {
        try
        {
            await LoadingService.ShowLoading();
            await OrganizeDrives();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading drives.");
            ToastService.Notify(new(ToastType.Danger, $"Error: {ex.Message}."));
        }
        finally
        {
            await LoadingService.HideLoading();
        }
    }

    private async Task OrganizeDrives()
    {
        var activeDrives = await DriveService.UpdateActiveDrivesAsync();
        Logger.LogInformation($"Found {activeDrives.Count} active drives.");

        PoolGroups = await DbContext.PoolGroups.Include(pg => pg.Drives).ToListAsync();
        Logger.LogInformation($"Loaded {PoolGroups.Count} pool groups from the database.");

        ProtectedDrives = await DbContext.ProtectedDrives.ToListAsync();
        Logger.LogInformation($"Loaded {ProtectedDrives.Count} protected drives from the database.");

        bool changesMade = false; // Flag to track if any changes are made

        // Update connected status and properties for drives in pools
        foreach (var pool in PoolGroups)
        {
            var duplicateDriveIds = pool.Drives
            .GroupBy(d => d.Id)
            .Where(g => g.Count() > 1)
            .Select(g => g.Key)
            .ToList();

            if (duplicateDriveIds.Any())
            {
                Logger.LogWarning($"Pool {pool.GroupLabel} has duplicate drive IDs: {string.Join(", ", duplicateDriveIds)}");

                // Remove duplicate drives
                pool.Drives = pool.Drives
                .GroupBy(d => d.Id)
                .Select(g => g.First())
                .ToList();
                changesMade = true;
            }

            bool allConnected = true;
            foreach (var drive in pool.Drives)
            {
                // Find matching active drive
                var activeDrive = activeDrives.FirstOrDefault(d => d.Serial == drive.Serial);
                if (activeDrive != null)
                {
                    // Update properties
                    if (!drive.IsConnected || drive.Vendor != activeDrive.Vendor || drive.Model != activeDrive.Model ||
                    drive.IsMounted != activeDrive.IsMounted || drive.DevPath != activeDrive.IdLink ||
                    drive.Size != activeDrive.Size)
                    {
                        drive.IsConnected = true;
                        drive.Vendor = activeDrive.Vendor;
                        drive.Model = activeDrive.Model;
                        drive.IsMounted = activeDrive.IsMounted;
                        drive.DevPath = activeDrive.IdLink;
                        drive.Size = activeDrive.Size;
                        changesMade = true;
                    }
                }
                else
                {
                    if (drive.IsConnected)
                    {
                        drive.IsConnected = false;
                        changesMade = true;
                    }
                    allConnected = false;
                }
            }

            // Set PoolEnabled based on whether all drives are connected
            pool.AllDrivesConnected = allConnected;

            if (pool.PoolEnabled)
            {
                // Fetch Pool Status
                string status = DriveService.FetchPoolStatus(pool.PoolGroupId);
                if (pool.PoolStatus != status)
                {
                    pool.PoolStatus = status;
                    changesMade = true;
                }

                if (!string.IsNullOrEmpty(pool.MountPath))
                {
                    var (size, used, available, usePercent) = DriveService.GetMountPointSize(pool.MountPath);

                    if (size > 0 && (pool.Size != size || pool.Used != used || pool.Available != available || pool.UsePercent !=
                    usePercent))
                    {
                        pool.Size = size;
                        pool.Used = used;
                        pool.Available = available;
                        pool.UsePercent = usePercent;
                        changesMade = true;
                    }
                }
            }
        }

        // NewDrives: drives that are active but not in any pool and not protected
        var pooledDriveSerials = PoolGroups.SelectMany(p => p.Drives).Select(d => d.Serial).ToHashSet();
        var protectedSerials = ProtectedDrives.Select(pd => pd.Serial).ToHashSet();

        // Ensure uniqueness by grouping by Serial
        NewDrives = activeDrives
        .Where(d => !pooledDriveSerials.Contains(d.Serial) && !protectedSerials.Contains(d.Serial))
        .GroupBy(d => d.Serial)
        .Select(g => g.First())
        .ToList();

        Logger.LogInformation($"NewDrives Count after filtering: {NewDrives.Count}");

        if (changesMade)
        {
            await DbContext.SaveChangesAsync();
            Logger.LogInformation("Changes saved to the database.");
        }
    }

    private async Task ProtectDrive(string serial)
    {
        try
        {
            Logger.LogInformation($"Attempting to protect drive with serial: {serial}");
            var result = await DriveService.ProtectDriveAsync(serial);
            if (result.Success)
            {
                Logger.LogInformation($"Drive {serial} protected successfully.");
                ToastService.Notify(new(ToastType.Success, $"{result.Message}"));
                await LoadDrives();
            }
            else
            {
                Logger.LogWarning($"Failed to protect drive {serial}: {result.Message}");
                ToastService.Notify(new(ToastType.Warning, $"{result.Message}"));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error protecting drive.");
            ToastService.Notify(new(ToastType.Warning, $"Error: {ex.Message}"));
        }
    }

    private async Task UnprotectDrive(string serial)
    {
        try
        {
            Logger.LogInformation($"Attempting to unprotect drive with serial: {serial}");
            var result = await DriveService.UnprotectDriveAsync(serial);
            if (result.Success)
            {
                Logger.LogInformation($"Drive {serial} unprotected successfully.");
                ToastService.Notify(new(ToastType.Success, $"{result.Message}"));
                await LoadDrives();
            }
            else
            {
                Logger.LogWarning($"Failed to unprotect drive {serial}: {result.Message}");
                ToastService.Notify(new(ToastType.Warning, $"{result.Message}"));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error unprotecting drive.");
            ToastService.Notify(new(ToastType.Warning, $"Error: {ex.Message}"));
        }
    }

    private void SelectDrive(string serial)
    {
        Logger.LogInformation($"Selecting drive with serial: {serial}");
        var drive = NewDrives.FirstOrDefault(d => d.Serial == serial);
        if (drive != null)
        {
            if (SelectedDrives.Any(d => d.Serial == serial))
            {
                // Deselect the drive
                SelectedDrives.RemoveAll(d => d.Serial == serial);
                Logger.LogInformation($"Drive {serial} deselected.");
            }
            else
            {
                // Select the drive
                SelectedDrives.Add(drive);
                Logger.LogInformation($"Drive {serial} selected.");
            }
            StateHasChanged(); // Update the UI
        }
        else
        {
            Logger.LogWarning($"Drive {serial} not found.");
            ToastService.Notify(new(ToastType.Danger, $"Drive {serial} not found."));
        }
    }

    private bool IsDriveSelected(string? serial)
    {
        if (serial == null)
            return false;
        return SelectedDrives.Any(d => d.Serial == serial);
    }

    private async Task OpenCreatePoolModal()
    {
        Logger.LogInformation("Opening Create Pool modal.");

        // Create a new CreatePoolRequest instance with selected drives
        CreatePoolRequest = new CreatePoolRequest
            {
                PoolLabel = "",
                DriveSerials = SelectedDrives.Select(d => d.Serial!).ToList(),
                DriveLabels = SelectedDrives.ToDictionary(d => d.Serial!, d => d.Label ?? "")
            };

        // Initialize CustomDriveLabels as empty since labels are pre-populated
        CustomDriveLabels.Clear();

        // Pre-populate drive labels with "PoolLabel-n"
        UpdateDriveLabelsBasedOnPoolLabel();

        // Reassign the EditContext to the new CreatePoolRequest instance
        createPoolEditContext = new EditContext(CreatePoolRequest);

        // Show the modal
        await createPoolModal.ShowAsync();
    }

    private async Task CloseCreatePoolModal()
    {
        // Reset the result message
        CreatePoolResultMessage = null;

        // Hide the modal
        await createPoolModal.HideAsync();

        // Clear selected drives
        SelectedDrives.Clear();

        // Reset CreatePoolRequest to a new instance
        CreatePoolRequest = new CreatePoolRequest
            {
                PoolLabel = string.Empty,
                DriveSerials = new List<string>(),
                DriveLabels = new Dictionary<string, string>()
            };

        // Reassign the EditContext to the new CreatePoolRequest instance
        createPoolEditContext = new EditContext(CreatePoolRequest);

        // Trigger UI update
        StateHasChanged();

        // Reload drives to refresh the state
        await LoadDrives();
    }

    private async Task HandleCreatePool()
    {
        Logger.LogInformation("Creating pool...");
        try
        {
            IsPoolCreationInProgress = true;
            CommandOutputs.Clear();
            CreatePoolResultMessage = null;
            CreatePoolResultSuccess = null;
            var (success, message, outputs) = await DriveService.CreatePoolAsync(CreatePoolRequest);
            CommandOutputs.AddRange(outputs);
            CreatePoolResultMessage = $"{message}";
            if (success)
            {
                Logger.LogInformation($"Pool created successfully: {message}");
                CreatePoolResultSuccess = true;
            }
            else
            {
                Logger.LogWarning($"Pool creation failed: {message}");
                CreatePoolResultSuccess = false;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error creating pool.");
            CreatePoolResultSuccess = false;
            CreatePoolResultMessage = $"{ex.Message}";
        }
        finally
        {
            IsPoolCreationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task UnmountPool(PoolGroup poolGroup)
    {
        try
        {
            await LoadingService.ShowLoading();
            var result = await DriveService.UnmountPoolAsync(poolGroup.PoolGroupGuid);
            if (result.Success)
            {
                ToastService.Notify(new ToastMessage(ToastType.Success, $"{result.Message}"));
                await LoadDrives();
            }
            else
            {
                if (result.Message.Contains("target is busy", StringComparison.OrdinalIgnoreCase))
                {
                    // Fetch processes using mount point
                    currentPoolGroupGuidForUnmount = poolGroup.PoolGroupGuid;
                    var mountPoint = poolGroup.MountPath;
                    ProcessList = await DriveService.GetProcessesUsingMountPointAsync(mountPoint);
                    await processListModal.ShowAsync();
                }
                else
                {
                    ToastService.Notify(new ToastMessage(ToastType.Warning, $"{result.Message}"));
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Error unmounting pool '{poolGroup.GroupLabel}'.");
            ToastService.Notify(new ToastMessage(ToastType.Danger, $"Failed to unmount pool."));
        }
        finally
        {
            await LoadingService.HideLoading();
        }
    }

    private async Task KillProcesses()
    {
        if (currentPoolGroupGuidForUnmount == null)
        {
            ToastService.Notify(new ToastMessage(ToastType.Warning, "No pool group selected for unmounting."));
            return;
        }

        try
        {
            await LoadingService.ShowLoading();

            var pids = ProcessList?.Select(p => p.PID).ToList() ?? new List<int>();
            if (!pids.Any())
            {
                ToastService.Notify(new ToastMessage(ToastType.Warning, "No processes to kill."));
                await processListModal.HideAsync();
                return;
            }

            var request = new KillProcessesRequest
                {
                    PoolGroupGuid = currentPoolGroupGuidForUnmount.Value,
                    Pids = pids,
                    Action = "UnmountPool"
                };

            var killResult = await DriveService.KillProcessesAsync(request);

            if (killResult.Success)
            {
                ToastService.Notify(new ToastMessage(ToastType.Success, killResult.Message));
                await processListModal.HideAsync();
                await LoadDrives();
            }
            else
            {
                ToastService.Notify(new ToastMessage(ToastType.Warning, killResult.Message));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error killing processes.");
            ToastService.Notify(new ToastMessage(ToastType.Danger, "Failed to kill processes."));
        }
        finally
        {
            await LoadingService.HideLoading();
            currentPoolGroupGuidForUnmount = null;
        }
    }

    private async Task CloseProcessListModal()
    {
        await processListModal.HideAsync();
        ProcessList = null;
        currentPoolGroupGuidForUnmount = null;
    }

    private async Task RemovePoolGroup(PoolGroup poolGroup)
    {
        try
        {
            await LoadingService.ShowLoading();
            var result = await DriveService.RemovePoolGroupAsync(poolGroup.PoolGroupGuid);
            if (result.Success)
            {
                ToastService.Notify(new(ToastType.Success, $"{result.Message}"));
                await LoadDrives();
            }
            else
            {
                ToastService.Notify(new(ToastType.Warning, $"{result.Message}"));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Error removing pool '{poolGroup.GroupLabel}'.");
            ToastService.Notify(new(ToastType.Danger, $"Failed to remove pool."));
        }
        finally
        {
            await LoadingService.HideLoading();
        }
    }

    private async Task MountPool(PoolGroup poolGroup)
    {
        try
        {
            await LoadingService.ShowLoading();
            var result = await DriveService.MountPoolAsync(poolGroup.PoolGroupGuid);
            if (result.Success)
            {
                ToastService.Notify(new(ToastType.Success, $"{result.Message}"));
                await LoadDrives();
            }
            else
            {
                ToastService.Notify(new(ToastType.Warning, $"{result.Message}"));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Error mounting pool '{poolGroup.GroupLabel}'.");
            ToastService.Notify(new(ToastType.Danger, $"Failed to mount pool."));
        }
        finally
        {
            await LoadingService.HideLoading();
        }
    }

    private async Task RenamePoolGroup(PoolGroup poolGroup)
    {
        Logger.LogInformation($"Renaming pool group: {poolGroup.GroupLabel}");
        PoolToRename = poolGroup;
        RenamePoolRequest = new RenamePoolRequest
            {
                PoolGroupGuid = poolGroup.PoolGroupGuid,
                NewPoolLabel = poolGroup.GroupLabel,
                DriveLabels = poolGroup.Drives.Select(d => new DriveLabel
                {
                    DriveId = d.Id,
                    Label = d.Label
                }).ToList()
            };
        renamePoolEditContext = new EditContext(RenamePoolRequest); // Reinitialize EditContext
        await renamePoolModal.ShowAsync();
    }

    private Task OnRenameDriveLabelChanged(int driveId, string newLabel)
    {
        var driveLabel = RenamePoolRequest.DriveLabels.FirstOrDefault(dl => dl.DriveId == driveId);
        if (driveLabel != null)
        {
            driveLabel.Label = newLabel;
        }
        return Task.CompletedTask;
    }
    private async Task ForceAddDrive(PoolDrive drive)
    {
        try
        {
            await LoadingService.ShowLoading();
            if (drive.PoolGroup != null && drive.DevPath != null)
            {
                var result = await DriveService.ForceAddDriveAsync(drive.Id, drive.PoolGroup.PoolGroupGuid, drive.DevPath);
                if (result.Success)
                {
                    ToastService.Notify(new(ToastType.Success, $"{result.Message}"));
                    await LoadDrives();
                }
                else
                {
                    ToastService.Notify(new(ToastType.Warning, $"{result.Message}"));
                }
            }
            else
            {
                Logger.LogWarning("Drive PoolGroup or DevPath is null.");
                ToastService.Notify(new(ToastType.Danger, "Failed to force add drive due to missing information."));
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Error force adding drive '{drive.Label}'.");
            ToastService.Notify(new(ToastType.Danger, $"Failed to force add drive."));
        }
        finally
        {
            await LoadingService.HideLoading();
        }
    }

    private async Task CloseRenamePoolModal()
    {
        PoolToRename = new PoolGroup(); // Initialize to avoid null reference
        RenamePoolRequest = new RenamePoolRequest
            {
                NewPoolLabel = string.Empty,
                DriveLabels = new List<Backy.Models.DriveLabel>()
            };
        await renamePoolModal.HideAsync();
    }

    private async Task HandleRenamePool()
    {
        Logger.LogInformation("Renaming pool...");
        try
        {
            IsRenameInProgress = true;
            RenameCommandOutputs.Clear();
            RenameResultMessage = null;
            RenameResultSuccess = null;

            var (success, message) = await DriveService.RenamePoolGroupAsync(RenamePoolRequest);
            RenameResultMessage = message;

            if (success)
            {
                Logger.LogInformation($"Pool renamed successfully: {message}");
                RenameResultSuccess = true;
            }
            else
            {
                Logger.LogWarning($"Pool renaming failed: {message}");
                RenameResultSuccess = false;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error renaming pool.");
            RenameResultSuccess = false;
            RenameResultMessage = ex.Message;
        }
        finally
        {
            IsRenameInProgress = false;
            StateHasChanged();
        }
    }

    /// <summary>
    /// Updates drive labels based on the current pool label.
    /// Only updates labels that have not been manually set.
    /// </summary>
    private void UpdateDriveLabelsBasedOnPoolLabel()
    {
        if (string.IsNullOrWhiteSpace(CreatePoolRequest.PoolLabel))
            return;

        int counter = 1;
        foreach (var serial in CreatePoolRequest.DriveSerials)
        {
            if (!CustomDriveLabels.Contains(serial))
            {
                CreatePoolRequest.DriveLabels[serial] = $"{CreatePoolRequest.PoolLabel}-{counter}";
                counter++;
            }
        }
    }

    /// <summary>
    /// Event handler when the pool label is changed.
    /// Updates drive labels accordingly.
    /// </summary>
    private async Task HandlePoolLabelChanged(ChangeEventArgs e)
    {
        string newPoolLabel = e.Value?.ToString() ?? string.Empty;
        CreatePoolRequest.PoolLabel = newPoolLabel;
        UpdateDriveLabelsBasedOnPoolLabel();
        await InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// Event handler when a drive label is changed manually.
    /// Marks the drive label as custom to prevent automatic overrides.
    /// </summary>
    private Task OnDriveLabelChanged(string serial, string newLabel)
    {
        if (!string.IsNullOrWhiteSpace(newLabel))
        {
            CustomDriveLabels.Add(serial);
            CreatePoolRequest.DriveLabels[serial] = newLabel;
        }
        else
        {
            CustomDriveLabels.Remove(serial);
            // Re-populate with default if pool label exists
            if (!string.IsNullOrWhiteSpace(CreatePoolRequest.PoolLabel))
            {
                int driveIndex = CreatePoolRequest.DriveSerials.IndexOf(serial) + 1;
                CreatePoolRequest.DriveLabels[serial] = $"{CreatePoolRequest.PoolLabel}-{driveIndex}";
            }
        }
        return Task.CompletedTask;
    }
}
